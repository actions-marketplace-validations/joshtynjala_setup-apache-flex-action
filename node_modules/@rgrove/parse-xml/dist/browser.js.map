{
  "version": 3,
  "sources": ["../src/index.ts", "../src/lib/StringScanner.ts", "../src/lib/syntax.ts", "../src/lib/XmlNode.ts", "../src/lib/XmlText.ts", "../src/lib/XmlCdata.ts", "../src/lib/XmlComment.ts", "../src/lib/XmlElement.ts", "../src/lib/XmlDocument.ts", "../src/lib/XmlProcessingInstruction.ts", "../src/lib/Parser.ts"],
  "sourcesContent": ["import { Parser } from './lib/Parser.js';\n\nimport type { ParserOptions } from './lib/Parser.js';\n\nexport * from './lib/types.js';\nexport { XmlCdata } from './lib/XmlCdata.js';\nexport { XmlComment } from './lib/XmlComment.js';\nexport { XmlDocument } from './lib/XmlDocument.js';\nexport { XmlElement } from './lib/XmlElement.js';\nexport { XmlNode } from './lib/XmlNode.js';\nexport { XmlProcessingInstruction } from './lib/XmlProcessingInstruction.js';\nexport { XmlText } from './lib/XmlText.js';\n\nexport type { ParserOptions } from './lib/Parser.js';\n\n/**\n * Parses the given XML string and returns an `XmlDocument` instance\n * representing the document tree.\n *\n * @example\n *\n * import { parseXml } from '@rgrove/parse-xml';\n * let doc = parseXml('<kittens fuzzy=\"yes\">I like fuzzy kittens.</kittens>');\n *\n * @param xml XML string to parse.\n * @param options Parser options.\n */\nexport function parseXml(xml: string, options?: ParserOptions) {\n  return (new Parser(xml, options)).document;\n}\n", "const emptyString = '';\nconst surrogatePair = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n\n/** @private */\nexport class StringScanner {\n  charIndex: number;\n  readonly string: string;\n\n  private readonly charCount: number;\n  private readonly charsToBytes: number[] | undefined;\n  private readonly length: number;\n  private readonly multiByteMode: boolean;\n\n  constructor(string: string) {\n    this.charCount = this.charLength(string, true);\n    this.charIndex = 0;\n    this.length = string.length;\n    this.multiByteMode = this.charCount !== this.length;\n    this.string = string;\n\n    if (this.multiByteMode) {\n      let charsToBytes = [];\n\n      // Create a mapping of character indexes to byte indexes. Since the string\n      // contains multibyte characters, a byte index may not necessarily align\n      // with a character index.\n      for (let byteIndex = 0, charIndex = 0; charIndex < this.charCount; ++charIndex) {\n        charsToBytes[charIndex] = byteIndex;\n        byteIndex += (string.codePointAt(byteIndex) as number) > 65535 ? 2 : 1;\n      }\n\n      this.charsToBytes = charsToBytes;\n    }\n  }\n\n  /**\n   * Whether the current character index is at the end of the input string.\n   */\n  get isEnd() {\n    return this.charIndex >= this.charCount;\n  }\n\n  // -- Protected Methods ------------------------------------------------------\n\n  /**\n   * Returns the byte index of the given character index in the string. The two\n   * may differ in strings that contain multibyte characters.\n   */\n  protected charIndexToByteIndex(charIndex: number = this.charIndex): number {\n    return this.multiByteMode\n      ? (this.charsToBytes as number[])[charIndex] ?? Infinity\n      : charIndex;\n  }\n\n  /**\n   * Returns the number of characters in the given string, which may differ from\n   * the byte length if the string contains multibyte characters.\n   */\n  protected charLength(string: string, multiByteSafe = this.multiByteMode): number {\n    // We could get the char length with `[ ...string ].length`, but that's\n    // actually slower than replacing surrogate pairs with single-byte\n    // characters and then counting the result.\n    return multiByteSafe\n      ? string.replace(surrogatePair, '_').length\n      : string.length;\n  }\n\n  // -- Public Methods ---------------------------------------------------------\n\n  /**\n   * Advances the scanner by the given number of characters, stopping if the end\n   * of the string is reached.\n   */\n  advance(count = 1) {\n    this.charIndex = Math.min(this.charCount, this.charIndex + count);\n  }\n\n  /**\n   * Consumes and returns the given number of characters if possible, advancing\n   * the scanner and stopping if the end of the string is reached.\n   *\n   * If no characters could be consumed, an empty string will be returned.\n   */\n  consume(count = 1): string {\n    let chars = this.peek(count);\n    this.advance(count);\n    return chars;\n  }\n\n  /**\n   * Consumes a match for the given sticky regex, advances the scanner, updates\n   * the `lastIndex` property of the regex, and returns the matching string.\n   *\n   * The regex must have a sticky flag (\"y\") so that its `lastIndex` prop can be\n   * used to anchor the match at the current scanner position.\n   *\n   * Returns the consumed string, or an empty string if nothing was consumed.\n   */\n  consumeMatch(regex: RegExp): string {\n    if (!regex.sticky) {\n      throw new Error('`regex` must have a sticky flag (\"y\")');\n    }\n\n    regex.lastIndex = this.charIndexToByteIndex();\n\n    let result = regex.exec(this.string);\n\n    if (result === null || result.length === 0) {\n      return emptyString;\n    }\n\n    let match = result[0] as string;\n    this.advance(this.charLength(match));\n    return match;\n  }\n\n  /**\n   * Consumes and returns all characters for which the given function returns a\n   * truthy value, stopping on the first falsy return value or if the end of the\n   * input is reached.\n   */\n  consumeMatchFn(fn: (char: string) => boolean): string {\n    let char;\n    let match = emptyString;\n\n    while ((char = this.peek()) && fn(char)) {\n      match += char;\n      this.advance();\n    }\n\n    return match;\n  }\n\n  /**\n   * Consumes the given string if it exists at the current character index, and\n   * advances the scanner.\n   *\n   * If the given string doesn't exist at the current character index, an empty\n   * string will be returned and the scanner will not be advanced.\n   */\n  consumeString(stringToConsume: string): string {\n    if (this.consumeStringFast(stringToConsume)) {\n      return stringToConsume;\n    }\n\n    if (this.multiByteMode) {\n      let { length } = stringToConsume;\n      let charLengthToMatch = this.charLength(stringToConsume);\n\n      if (charLengthToMatch !== length\n          && stringToConsume === this.peek(charLengthToMatch)) {\n\n        this.advance(charLengthToMatch);\n        return stringToConsume;\n      }\n    }\n\n    return emptyString;\n  }\n\n  /**\n   * Does the same thing as `consumeString()`, but doesn't support consuming\n   * multibyte characters. This can be faster if you only need to match single\n   * byte characters.\n   */\n  consumeStringFast(stringToConsume: string): string {\n    let { length } = stringToConsume;\n\n    if (this.peek(length) === stringToConsume) {\n      this.advance(length);\n      return stringToConsume;\n    }\n\n    return emptyString;\n  }\n\n  /**\n   * Consumes characters until the given global regex is matched, advancing the\n   * scanner up to (but not beyond) the beginning of the match. If the regex\n   * doesn't match, nothing will be consumed.\n   *\n   * Returns the consumed string, or an empty string if nothing was consumed.\n   */\n  consumeUntilMatch(regex: RegExp): string {\n    let restOfString = this.string.slice(this.charIndexToByteIndex());\n    let matchByteIndex = restOfString.search(regex);\n\n    if (matchByteIndex <= 0) {\n      return emptyString;\n    }\n\n    let result = restOfString.slice(0, matchByteIndex);\n    this.advance(this.charLength(result));\n    return result;\n  }\n\n  /**\n   * Consumes characters until the given string is found, advancing the scanner\n   * up to (but not beyond) that point. If the string is never found, nothing\n   * will be consumed.\n   *\n   * Returns the consumed string, or an empty string if nothing was consumed.\n   */\n  consumeUntilString(searchString: string): string {\n    let { string } = this;\n    let byteIndex = this.charIndexToByteIndex();\n    let matchByteIndex = string.indexOf(searchString, byteIndex);\n\n    if (matchByteIndex <= 0) {\n      return emptyString;\n    }\n\n    let result = string.slice(byteIndex, matchByteIndex);\n    this.advance(this.charLength(result));\n    return result;\n  }\n\n  /**\n   * Returns the given number of characters starting at the current character\n   * index, without advancing the scanner and without exceeding the end of the\n   * input string.\n   */\n  peek(count = 1): string {\n    let { charIndex, multiByteMode, string } = this;\n\n    if (multiByteMode) {\n      // Inlining this comparison instead of checking `this.isEnd` improves perf\n      // slightly since `peek()` is called so frequently.\n      if (charIndex >= this.charCount) {\n        return emptyString;\n      }\n\n      return string.slice(\n        this.charIndexToByteIndex(charIndex),\n        this.charIndexToByteIndex(charIndex + count),\n      );\n    }\n\n    return string.slice(charIndex, charIndex + count);\n  }\n\n  /**\n   * Resets the scanner position to the given character _index_, or to the start\n   * of the input string if no index is given.\n   *\n   * If _index_ is negative, the scanner position will be moved backward by that\n   * many characters, stopping if the beginning of the string is reached.\n   */\n  reset(index = 0) {\n    this.charIndex = index >= 0\n      ? Math.min(this.charCount, index)\n      : Math.max(0, this.charIndex + index);\n  }\n}\n", "/**\n * Regular expression that matches one or more `AttValue` characters in a\n * double-quoted attribute value.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-AttValue\n */\nexport const attValueCharDoubleQuote = /[^\"&<]+/y;\n\n/**\n * Regular expression that matches one or more `AttValue` characters in a\n * single-quoted attribute value.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-AttValue\n */\nexport const attValueCharSingleQuote = /[^'&<]+/y;\n\n/**\n * Regular expression that matches a whitespace character that should be\n * normalized to a space character in an attribute value.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#AVNormalize\n */\nexport const attValueNormalizedWhitespace = /[\\t\\n]/g;\n\n/**\n * Regular expression that matches one or more characters that signal the end of\n * XML `CharData` content.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#dt-chardata\n */\nexport const endCharData = /<|&|]]>/;\n\n/**\n * Mapping of predefined entity names to their replacement values.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-predefined-ent\n */\nexport const predefinedEntities: Readonly<{[name: string]: string;}> = Object.freeze(Object.assign(Object.create(null), {\n  amp: '&',\n  apos: \"'\",\n  gt: '>',\n  lt: '<',\n  quot: '\"',\n}));\n\n/**\n * Returns `true` if _char_ is an XML `NameChar`, `false` if it isn't.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-NameChar\n */\nexport function isNameChar(char: string): boolean {\n  let cp = getCodePoint(char);\n\n  // Including the most common NameStartChars here improves performance\n  // slightly.\n  return (cp >= 0x61 && cp <= 0x7A) // a-z\n    || (cp >= 0x41 && cp <= 0x5A) // A-Z\n    || (cp >= 0x30 && cp <= 0x39) // 0-9\n    || cp === 0x2D // -\n    || cp === 0x2E // .\n    || cp === 0xB7\n    || (cp >= 0x300 && cp <= 0x36F)\n    || (cp >= 0x203F && cp <= 0x2040)\n    || isNameStartChar(char, cp);\n}\n\n/**\n * Returns `true` if _char_ is an XML `NameStartChar`, `false` if it isn't.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-NameStartChar\n */\nexport function isNameStartChar(char: string, cp = getCodePoint(char)): boolean {\n  return (cp >= 0x61 && cp <= 0x7A) // a-z\n    || (cp >= 0x41 && cp <= 0x5A) // A-Z\n    || cp === 0x3A // :\n    || cp === 0x5F // _\n    || (cp >= 0xC0 && cp <= 0xD6)\n    || (cp >= 0xD8 && cp <= 0xF6)\n    || (cp >= 0xF8 && cp <= 0x2FF)\n    || (cp >= 0x370 && cp <= 0x37D)\n    || (cp >= 0x37F && cp <= 0x1FFF)\n    || (cp >= 0x200C && cp <= 0x200D)\n    || (cp >= 0x2070 && cp <= 0x218F)\n    || (cp >= 0x2C00 && cp <= 0x2FEF)\n    || (cp >= 0x3001 && cp <= 0xD7FF)\n    || (cp >= 0xF900 && cp <= 0xFDCF)\n    || (cp >= 0xFDF0 && cp <= 0xFFFD)\n    || (cp >= 0x10000 && cp <= 0xEFFFF);\n}\n\n/**\n * Returns `true` if _char_ is a valid reference character (which may appear\n * between `&` and `;` in a reference), `false` otherwise.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-references\n */\nexport function isReferenceChar(char: string): boolean {\n  return char === '#' || isNameChar(char);\n}\n\n/**\n * Returns `true` if _char_ is an XML whitespace character, `false` otherwise.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#white\n */\nexport function isWhitespace(char: string): boolean {\n  let cp = getCodePoint(char);\n\n  return cp === 0x20\n    || cp === 0x9\n    || cp === 0xA\n    || cp === 0xD;\n}\n\n/**\n * Returns `true` if _codepoint_ is a valid XML `Char` code point, `false`\n * otherwise.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Char\n */\nexport function isXmlCodePoint(cp: number): boolean {\n  return cp === 0x9\n    || cp === 0xA\n    || cp === 0xD\n    || (cp >= 0x20 && cp <= 0xD7FF)\n    || (cp >= 0xE000 && cp <= 0xFFFD)\n    || (cp >= 0x10000 && cp <= 0x10FFFF);\n}\n\n/**\n * Returns the Unicode code point value of the given character, or `-1` if\n * _char_ is empty.\n */\nfunction getCodePoint(char: string): number {\n  return char.codePointAt(0) || -1;\n}\n", "import type { JsonObject } from './types.js';\nimport type { XmlDocument } from './XmlDocument.js';\nimport type { XmlElement } from './XmlElement.js';\n\n/**\n * Base interface for a node in an XML document.\n */\nexport class XmlNode {\n  /**\n   * Type value for an `XmlCdata` node.\n   */\n  static readonly TYPE_CDATA = 'cdata';\n\n  /**\n   * Type value for an `XmlComment` node.\n   */\n  static readonly TYPE_COMMENT = 'comment';\n\n  /**\n   * Type value for an `XmlDocument` node.\n   */\n  static readonly TYPE_DOCUMENT = 'document';\n\n  /**\n   * Type value for an `XmlElement` node.\n   */\n  static readonly TYPE_ELEMENT = 'element';\n\n  /**\n   * Type value for an `XmlProcessingInstruction` node.\n   */\n  static readonly TYPE_PROCESSING_INSTRUCTION = 'pi';\n\n  /**\n   * Type value for an `XmlText` node.\n   */\n  static readonly TYPE_TEXT = 'text';\n\n  /**\n   * Parent node of this node, or `null` if this node has no parent.\n   */\n  parent: XmlDocument | XmlElement | null = null;\n\n  /**\n   * Document that contains this node, or `null` if this node is not associated\n   * with a document.\n   */\n  get document(): XmlDocument | null {\n    return this.parent?.document ?? null;\n  }\n\n  /**\n   * Whether this node is the root node of the document.\n   */\n  get isRootNode(): boolean {\n    return this.parent !== null && this.parent === this.document;\n  }\n\n  /**\n   * Whether whitespace should be preserved in the content of this element and\n   * its children.\n   *\n   * This is influenced by the value of the special `xml:space` attribute, and\n   * will be `true` for any node whose `xml:space` attribute is set to\n   * \"preserve\". If a node has no such attribute, it will inherit the value of\n   * the nearest ancestor that does (if any).\n   *\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-white-space\n   */\n  get preserveWhitespace(): boolean {\n    return Boolean(this.parent?.preserveWhitespace);\n  }\n\n  /**\n   * Type of this node.\n   *\n   * The value of this property is a string that matches one of the static\n   * `TYPE_*` properties on the `XmlNode` class (e.g. `TYPE_ELEMENT`,\n   * `TYPE_TEXT`, etc.).\n   *\n   * The `XmlNode` class itself is a base class and doesn't have its own type\n   * name.\n   */\n  get type() {\n    return '';\n  }\n\n  /**\n   * Returns a JSON-serializable object representing this node, minus properties\n   * that could result in circular references.\n   */\n  toJSON(): JsonObject {\n    let json: JsonObject = {\n      type: this.type,\n    };\n\n    if (this.isRootNode) {\n      json.isRootNode = true;\n    }\n\n    if (this.preserveWhitespace) {\n      json.preserveWhitespace = true;\n    }\n\n    return json;\n  }\n}\n", "import { XmlNode } from './XmlNode.js';\n\n/**\n * Text content within an XML document.\n */\nexport class XmlText extends XmlNode {\n  /**\n   * Text content of this node.\n   */\n  text: string;\n\n  constructor(text = '') {\n    super();\n    this.text = text;\n  }\n\n  override get type() {\n    return XmlNode.TYPE_TEXT;\n  }\n\n  override toJSON() {\n    return Object.assign(XmlNode.prototype.toJSON.call(this), {\n      text: this.text,\n    });\n  }\n}\n", "import { XmlNode } from './XmlNode.js';\nimport { XmlText } from './XmlText.js';\n\n/**\n * A CDATA section within an XML document.\n */\nexport class XmlCdata extends XmlText {\n  override get type() {\n    return XmlNode.TYPE_CDATA;\n  }\n}\n", "import { XmlNode } from './XmlNode.js';\n\n/**\n * A comment within an XML document.\n */\nexport class XmlComment extends XmlNode {\n  /**\n   * Content of this comment.\n   */\n  content: string;\n\n  constructor(content = '') {\n    super();\n    this.content = content;\n  }\n\n  override get type() {\n    return XmlNode.TYPE_COMMENT;\n  }\n\n  override toJSON() {\n    return Object.assign(XmlNode.prototype.toJSON.call(this), {\n      content: this.content,\n    });\n  }\n}\n", "import { XmlNode } from './XmlNode.js';\n\nimport type { JsonObject } from './types.js';\nimport type { XmlCdata } from './XmlCdata.js';\nimport type { XmlComment } from './XmlComment.js';\nimport type { XmlProcessingInstruction } from './XmlProcessingInstruction.js';\nimport type { XmlText } from './XmlText.js';\n\n/**\n * Element in an XML document.\n */\nexport class XmlElement extends XmlNode {\n  /**\n   * Attributes on this element.\n   */\n  attributes: {[attrName: string]: string};\n\n  /**\n   * Child nodes of this element.\n   */\n  children: Array<XmlCdata | XmlComment | XmlElement | XmlProcessingInstruction | XmlText>;\n\n  /**\n   * Name of this element.\n   */\n  name: string;\n\n  constructor(\n    name: string,\n    attributes: {[attrName: string]: string} = Object.create(null),\n    children: Array<XmlCdata | XmlComment | XmlElement | XmlProcessingInstruction | XmlText> = [],\n  ) {\n    super();\n\n    this.name = name;\n    this.attributes = attributes;\n    this.children = children;\n  }\n\n  /**\n   * Whether this element is empty (meaning it has no children).\n   */\n  get isEmpty(): boolean {\n    return this.children.length === 0;\n  }\n\n  override get preserveWhitespace(): boolean {\n    let node: XmlNode | null = this; // eslint-disable-line @typescript-eslint/no-this-alias\n\n    while (node instanceof XmlElement) {\n      if ('xml:space' in node.attributes) {\n        return node.attributes['xml:space'] === 'preserve';\n      }\n\n      node = node.parent;\n    }\n\n    return false;\n  }\n\n  /**\n   * Text content of this element and all its descendants.\n   */\n  get text(): string {\n    return this.children\n      .map(child => 'text' in child ? child.text : '')\n      .join('');\n  }\n\n  override get type() {\n    return XmlNode.TYPE_ELEMENT;\n  }\n\n  override toJSON(): JsonObject {\n    return Object.assign(XmlNode.prototype.toJSON.call(this), {\n      name: this.name,\n      attributes: this.attributes,\n      children: this.children.map(child => child.toJSON()),\n    });\n  }\n}\n", "import { XmlElement } from './XmlElement.js';\nimport { XmlNode } from './XmlNode.js';\n\nimport type { XmlComment } from './XmlComment.js';\nimport type { XmlProcessingInstruction } from './XmlProcessingInstruction.js';\n\n/**\n * Represents an XML document. All elements within the document are descendants\n * of this node.\n */\nexport class XmlDocument extends XmlNode {\n  /**\n   * Child nodes of this document.\n   */\n  readonly children: Array<XmlComment | XmlProcessingInstruction | XmlElement>;\n\n  constructor(children: Array<XmlComment | XmlElement | XmlProcessingInstruction> = []) {\n    super();\n    this.children = children;\n  }\n\n  override get document() {\n    return this;\n  }\n\n  /**\n   * Root element of this document, or `null` if this document is empty.\n   */\n  get root(): XmlElement | null {\n    for (let child of this.children) {\n      if (child instanceof XmlElement) {\n        return child;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Text content of this document and all its descendants.\n   */\n  get text(): string {\n    return this.children\n      .map(child => 'text' in child ? child.text : '')\n      .join('');\n  }\n\n  override get type() {\n    return XmlNode.TYPE_DOCUMENT;\n  }\n\n  override toJSON() {\n    return Object.assign(XmlNode.prototype.toJSON.call(this), {\n      children: this.children.map(child => child.toJSON()),\n    });\n  }\n}\n", "import { XmlNode } from './XmlNode.js';\n\n/**\n * A processing instruction within an XML document.\n */\nexport class XmlProcessingInstruction extends XmlNode {\n  /**\n   * Content of this processing instruction.\n   */\n  content: string;\n\n  /**\n   * Name of this processing instruction. Also sometimes referred to as the\n   * processing instruction \"target\".\n   */\n  name: string;\n\n  constructor(name: string, content = '') {\n    super();\n\n    this.name = name;\n    this.content = content;\n  }\n\n  override get type() {\n    return XmlNode.TYPE_PROCESSING_INSTRUCTION;\n  }\n\n  override toJSON() {\n    return Object.assign(XmlNode.prototype.toJSON.call(this), {\n      name: this.name,\n      content: this.content,\n    });\n  }\n}\n", "import { StringScanner } from './StringScanner.js';\nimport * as syntax from './syntax.js';\nimport { XmlCdata } from './XmlCdata.js';\nimport { XmlComment } from './XmlComment.js';\nimport { XmlDocument } from './XmlDocument.js';\nimport { XmlElement } from './XmlElement.js';\nimport { XmlProcessingInstruction } from './XmlProcessingInstruction.js';\nimport { XmlText } from './XmlText.js';\n\nimport type { XmlNode } from './XmlNode.js';\n\n\nconst emptyString = '';\n\n/**\n * Parses an XML string into an `XmlDocument`.\n *\n * @private\n */\nexport class Parser {\n  readonly document: XmlDocument;\n\n  private currentNode: XmlDocument | XmlElement;\n  private readonly options: ParserOptions;\n  private readonly scanner: StringScanner;\n\n  /**\n   * @param xml XML string to parse.\n   * @param options Parser options.\n   */\n  constructor(xml: string, options: ParserOptions = {}) {\n    this.document = new XmlDocument();\n    this.currentNode = this.document;\n    this.options = options;\n    this.scanner = new StringScanner(normalizeXmlString(xml));\n\n    this.consumeProlog();\n\n    if (!this.consumeElement()) {\n      throw this.error('Root element is missing or invalid');\n    }\n\n    while (this.consumeMisc()) {} // eslint-disable-line no-empty\n\n    if (!this.scanner.isEnd) {\n      throw this.error('Extra content at the end of the document');\n    }\n  }\n\n  /**\n   * Adds the given `XmlNode` as a child of `this.currentNode`.\n   */\n  addNode(node: XmlNode) {\n    node.parent = this.currentNode;\n\n    // @ts-expect-error: XmlDocument has a more limited set of possible children\n    // than XmlElement so TypeScript is unhappy, but we always do the right\n    // thing.\n    this.currentNode.children.push(node);\n  }\n\n  /**\n   * Adds the given _text_ to the document, either by appending it to a\n   * preceding `XmlText` node (if possible) or by creating a new `XmlText` node.\n   */\n  addText(text: string) {\n    let { children } = this.currentNode;\n    let { length } = children;\n\n    if (length > 0) {\n      let prevNode = children[length - 1];\n\n      if (prevNode instanceof XmlText) {\n        // The previous node is a text node, so we can append to it and avoid\n        // creating another node.\n        prevNode.text += text;\n        return;\n      }\n    }\n\n    this.addNode(new XmlText(text));\n  }\n\n  /**\n   * Consumes element attributes.\n   *\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-starttags\n   */\n  consumeAttributes(): Record<string, string> {\n    let attributes = Object.create(null);\n\n    while (this.consumeWhitespace()) {\n      let attrName = this.consumeName();\n\n      if (!attrName) {\n        break;\n      }\n\n      let attrValue = this.consumeEqual() && this.consumeAttributeValue();\n\n      if (attrValue === false) {\n        throw this.error('Attribute value expected');\n      }\n\n      if (attrName in attributes) {\n        throw this.error(`Duplicate attribute: ${attrName}`);\n      }\n\n      if (attrName === 'xml:space'\n          && attrValue !== 'default'\n          && attrValue !== 'preserve') {\n\n        throw this.error('Value of the `xml:space` attribute must be \"default\" or \"preserve\"');\n      }\n\n      attributes[attrName] = attrValue;\n    }\n\n    if (this.options.sortAttributes) {\n      let attrNames = Object.keys(attributes).sort();\n      let sortedAttributes = Object.create(null);\n\n      for (let i = 0; i < attrNames.length; ++i) {\n        let attrName = attrNames[i] as string;\n        sortedAttributes[attrName] = attributes[attrName];\n      }\n\n      attributes = sortedAttributes;\n    }\n\n    return attributes;\n  }\n\n  /**\n   * Consumes an `AttValue` (attribute value) if possible.\n   *\n   * @returns\n   *   Contents of the `AttValue` minus quotes, or `false` if nothing was\n   *   consumed. An empty string indicates that an `AttValue` was consumed but\n   *   was empty.\n   *\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-AttValue\n   */\n  consumeAttributeValue(): string | false {\n    let { scanner } = this;\n    let quote = scanner.peek();\n\n    if (quote !== '\"' && quote !== \"'\") {\n      return false;\n    }\n\n    scanner.advance();\n\n    let chars;\n    let isClosed = false;\n    let value = emptyString;\n    let regex = quote === '\"'\n      ? syntax.attValueCharDoubleQuote\n      : syntax.attValueCharSingleQuote;\n\n    matchLoop: while (!scanner.isEnd) {\n      chars = scanner.consumeMatch(regex);\n\n      if (chars) {\n        this.validateChars(chars);\n        value += chars.replace(syntax.attValueNormalizedWhitespace, ' ');\n      }\n\n      switch (scanner.peek()) {\n        case quote:\n          isClosed = true;\n          break matchLoop;\n\n        case '&':\n          value += this.consumeReference();\n          continue;\n\n        case '<':\n          throw this.error('Unescaped `<` is not allowed in an attribute value');\n\n        case emptyString:\n          break matchLoop;\n      }\n    }\n\n    if (!isClosed) {\n      throw this.error('Unclosed attribute');\n    }\n\n    scanner.advance();\n    return value;\n  }\n\n  /**\n   * Consumes a CDATA section if possible.\n   *\n   * @returns Whether a CDATA section was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-cdata-sect\n   */\n  consumeCdataSection(): boolean {\n    let { scanner } = this;\n\n    if (!scanner.consumeStringFast('<![CDATA[')) {\n      return false;\n    }\n\n    let text = scanner.consumeUntilString(']]>');\n    this.validateChars(text);\n\n    if (!scanner.consumeStringFast(']]>')) {\n      throw this.error('Unclosed CDATA section');\n    }\n\n    if (this.options.preserveCdata) {\n      this.addNode(new XmlCdata(text));\n    } else {\n      this.addText(text);\n    }\n\n    return true;\n  }\n\n  /**\n   * Consumes character data if possible.\n   *\n   * @returns Whether character data was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#dt-chardata\n   */\n  consumeCharData(): boolean {\n    let { scanner } = this;\n    let charData = scanner.consumeUntilMatch(syntax.endCharData);\n\n    if (!charData) {\n      return false;\n    }\n\n    this.validateChars(charData);\n\n    if (scanner.peek(3) === ']]>') {\n      throw this.error('Element content may not contain the CDATA section close delimiter `]]>`');\n    }\n\n    this.addText(charData);\n    return true;\n  }\n\n  /**\n   * Consumes a comment if possible.\n   *\n   * @returns Whether a comment was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Comment\n   */\n  consumeComment(): boolean {\n    let { scanner } = this;\n\n    if (!scanner.consumeStringFast('<!--')) {\n      return false;\n    }\n\n    let content = scanner.consumeUntilString('--');\n    this.validateChars(content);\n\n    if (!scanner.consumeStringFast('-->')) {\n      if (scanner.peek(2) === '--') {\n        throw this.error(\"The string `--` isn't allowed inside a comment\");\n      }\n\n      throw this.error('Unclosed comment');\n    }\n\n    if (this.options.preserveComments) {\n      this.addNode(new XmlComment(content.trim()));\n    }\n\n    return true;\n  }\n\n  /**\n   * Consumes a reference in a content context if possible.\n   *\n   * This differs from `consumeReference()` in that a consumed reference will be\n   * added to the document as a text node instead of returned.\n   *\n   * @returns Whether a reference was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#entproc\n   */\n  consumeContentReference(): boolean {\n    let ref = this.consumeReference();\n\n    if (ref) {\n      this.addText(ref);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Consumes a doctype declaration if possible.\n   *\n   * This is a loose implementation since doctype declarations are currently\n   * discarded without further parsing.\n   *\n   * @returns Whether a doctype declaration was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#dtd\n   */\n  consumeDoctypeDeclaration(): boolean {\n    let { scanner } = this;\n\n    if (!scanner.consumeStringFast('<!DOCTYPE')\n        || !this.consumeWhitespace()) {\n\n      return false;\n    }\n\n    scanner.consumeMatch(/[^[>]+/y);\n\n    if (scanner.consumeMatch(/\\[[\\s\\S]+?\\][\\x20\\t\\r\\n]*>/y)) {\n      return true;\n    }\n\n    if (!scanner.consumeStringFast('>')) {\n      throw this.error('Unclosed doctype declaration');\n    }\n\n    return true;\n  }\n\n  /**\n   * Consumes an element if possible.\n   *\n   * @returns Whether an element was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-element\n   */\n  consumeElement(): boolean {\n    let { scanner } = this;\n    let mark = scanner.charIndex;\n\n    if (!scanner.consumeStringFast('<')) {\n      return false;\n    }\n\n    let name = this.consumeName();\n\n    if (!name) {\n      scanner.reset(mark);\n      return false;\n    }\n\n    let attributes = this.consumeAttributes();\n    let isEmpty = Boolean(scanner.consumeStringFast('/>'));\n    let element = new XmlElement(name, attributes);\n\n    element.parent = this.currentNode;\n\n    if (!isEmpty) {\n      if (!scanner.consumeStringFast('>')) {\n        throw this.error(`Unclosed start tag for element \\`${name}\\``);\n      }\n\n      this.currentNode = element;\n\n      do {\n        this.consumeCharData();\n      } while (\n        this.consumeElement()\n          || this.consumeContentReference()\n          || this.consumeCdataSection()\n          || this.consumeProcessingInstruction()\n          || this.consumeComment()\n      );\n\n      let endTagMark = scanner.charIndex;\n      let endTagName;\n\n      if (!scanner.consumeStringFast('</')\n          || !(endTagName = this.consumeName())\n          || endTagName !== name) {\n\n        scanner.reset(endTagMark);\n        throw this.error(`Missing end tag for element ${name}`);\n      }\n\n      this.consumeWhitespace();\n\n      if (!scanner.consumeStringFast('>')) {\n        throw this.error(`Unclosed end tag for element ${name}`);\n      }\n\n      this.currentNode = element.parent;\n    }\n\n    this.addNode(element);\n    return true;\n  }\n\n  /**\n   * Consumes an `Eq` production if possible.\n   *\n   * @returns Whether an `Eq` production was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Eq\n   */\n  consumeEqual(): boolean {\n    this.consumeWhitespace();\n\n    if (this.scanner.consumeStringFast('=')) {\n      this.consumeWhitespace();\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Consumes `Misc` content if possible.\n   *\n   * @returns Whether anything was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Misc\n   */\n  consumeMisc(): boolean {\n    return this.consumeComment()\n      || this.consumeProcessingInstruction()\n      || this.consumeWhitespace();\n  }\n\n  /**\n   * Consumes one or more `Name` characters if possible.\n   *\n   * @returns `Name` characters, or an empty string if none were consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Name\n   */\n  consumeName(): string {\n    return syntax.isNameStartChar(this.scanner.peek())\n      ? this.scanner.consumeMatchFn(syntax.isNameChar)\n      : emptyString;\n  }\n\n  /**\n   * Consumes a processing instruction if possible.\n   *\n   * @returns Whether a processing instruction was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-pi\n   */\n  consumeProcessingInstruction(): boolean {\n    let { scanner } = this;\n    let mark = scanner.charIndex;\n\n    if (!scanner.consumeStringFast('<?')) {\n      return false;\n    }\n\n    let name = this.consumeName();\n\n    if (name) {\n      if (name.toLowerCase() === 'xml') {\n        scanner.reset(mark);\n        throw this.error(\"XML declaration isn't allowed here\");\n      }\n    } else {\n      throw this.error('Invalid processing instruction');\n    }\n\n    if (!this.consumeWhitespace()) {\n      if (scanner.consumeStringFast('?>')) {\n        this.addNode(new XmlProcessingInstruction(name));\n        return true;\n      }\n\n      throw this.error('Whitespace is required after a processing instruction name');\n    }\n\n    let content = scanner.consumeUntilString('?>');\n    this.validateChars(content);\n\n    if (!scanner.consumeStringFast('?>')) {\n      throw this.error('Unterminated processing instruction');\n    }\n\n    this.addNode(new XmlProcessingInstruction(name, content));\n    return true;\n  }\n\n  /**\n   * Consumes a prolog if possible.\n   *\n   * @returns Whether a prolog was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-prolog-dtd\n   */\n  consumeProlog(): boolean {\n    let { scanner } = this;\n    let mark = scanner.charIndex;\n\n    this.consumeXmlDeclaration();\n\n    while (this.consumeMisc()) {} // eslint-disable-line no-empty\n\n    if (this.consumeDoctypeDeclaration()) {\n      while (this.consumeMisc()) {} // eslint-disable-line no-empty\n    }\n\n    return mark < scanner.charIndex;\n  }\n\n  /**\n   * Consumes a reference if possible.\n   *\n   * This differs from `consumeContentReference()` in that a consumed reference\n   * will be returned rather than added to the document.\n   *\n   * @returns\n   *   Parsed reference value, or `false` if nothing was consumed (to\n   *   distinguish from a reference that resolves to an empty string).\n   *\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Reference\n   */\n  consumeReference(): string | false {\n    let { scanner } = this;\n\n    if (!scanner.consumeStringFast('&')) {\n      return false;\n    }\n\n    let ref = scanner.consumeMatchFn(syntax.isReferenceChar);\n\n    if (scanner.consume() !== ';') {\n      throw this.error('Unterminated reference (a reference must end with `;`)');\n    }\n\n    let parsedValue;\n\n    if (ref[0] === '#') {\n      // This is a character reference.\n      let codePoint = ref[1] === 'x'\n        ? parseInt(ref.slice(2), 16) // Hex codepoint.\n        : parseInt(ref.slice(1), 10); // Decimal codepoint.\n\n      if (isNaN(codePoint)) {\n        throw this.error('Invalid character reference');\n      }\n\n      if (!syntax.isXmlCodePoint(codePoint)) {\n        throw this.error('Character reference resolves to an invalid character');\n      }\n\n      parsedValue = String.fromCodePoint(codePoint);\n    } else {\n      // This is an entity reference.\n      parsedValue = syntax.predefinedEntities[ref];\n\n      if (parsedValue === undefined) {\n        let {\n          ignoreUndefinedEntities,\n          resolveUndefinedEntity,\n        } = this.options;\n\n        let wrappedRef = `&${ref};`; // for backcompat with <= 2.x\n\n        if (resolveUndefinedEntity) {\n          let resolvedValue = resolveUndefinedEntity(wrappedRef);\n\n          if (resolvedValue !== null && resolvedValue !== undefined) {\n            let type = typeof resolvedValue;\n\n            if (type !== 'string') {\n              throw new TypeError(`\\`resolveUndefinedEntity()\\` must return a string, \\`null\\`, or \\`undefined\\`, but returned a value of type ${type}`);\n            }\n\n            return resolvedValue;\n          }\n        }\n\n        if (ignoreUndefinedEntities) {\n          return wrappedRef;\n        }\n\n        scanner.reset(-wrappedRef.length);\n        throw this.error(`Named entity isn't defined: ${wrappedRef}`);\n      }\n    }\n\n    return parsedValue;\n  }\n\n  /**\n   * Consumes a `SystemLiteral` if possible.\n   *\n   * A `SystemLiteral` is similar to an attribute value, but allows the\n   * characters `<` and `&` and doesn't replace references.\n   *\n   * @returns\n   *   Value of the `SystemLiteral` minus quotes, or `false` if nothing was\n   *   consumed. An empty string indicates that a `SystemLiteral` was consumed\n   *   but was empty.\n   *\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-SystemLiteral\n   */\n  consumeSystemLiteral(): string | false {\n    let { scanner } = this;\n    let quote = scanner.consumeStringFast('\"') || scanner.consumeStringFast(\"'\");\n\n    if (!quote) {\n      return false;\n    }\n\n    let value = scanner.consumeUntilString(quote);\n    this.validateChars(value);\n\n    if (!scanner.consumeStringFast(quote)) {\n      throw this.error('Missing end quote');\n    }\n\n    return value;\n  }\n\n  /**\n   * Consumes one or more whitespace characters if possible.\n   *\n   * @returns Whether any whitespace characters were consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#white\n   */\n  consumeWhitespace(): boolean {\n    return Boolean(this.scanner.consumeMatchFn(syntax.isWhitespace));\n  }\n\n  /**\n   * Consumes an XML declaration if possible.\n   *\n   * @returns Whether an XML declaration was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-XMLDecl\n   */\n  consumeXmlDeclaration(): boolean {\n    let { scanner } = this;\n\n    if (!scanner.consumeStringFast('<?xml')) {\n      return false;\n    }\n\n    if (!this.consumeWhitespace()) {\n      throw this.error('Invalid XML declaration');\n    }\n\n    let version = Boolean(scanner.consumeStringFast('version'))\n      && this.consumeEqual()\n      && this.consumeSystemLiteral();\n\n    if (version === false) {\n      throw this.error('XML version is missing or invalid');\n    } else if (!/^1\\.[0-9]+$/.test(version)) {\n      throw this.error('Invalid character in version number');\n    }\n\n    if (this.consumeWhitespace()) {\n      let encoding = Boolean(scanner.consumeStringFast('encoding'))\n        && this.consumeEqual()\n        && this.consumeSystemLiteral();\n\n      if (encoding) {\n        this.consumeWhitespace();\n      }\n\n      let standalone = Boolean(scanner.consumeStringFast('standalone'))\n        && this.consumeEqual()\n        && this.consumeSystemLiteral();\n\n      if (standalone) {\n        if (standalone !== 'yes' && standalone !== 'no') {\n          throw this.error('Only \"yes\" and \"no\" are permitted as values of `standalone`');\n        }\n\n        this.consumeWhitespace();\n      }\n    }\n\n    if (!scanner.consumeStringFast('?>')) {\n      throw this.error('Invalid or unclosed XML declaration');\n    }\n\n    return true;\n  }\n\n  /**\n   * Throws an error at the current scanner position.\n   */\n  error(message: string) {\n    let { charIndex, string: xml } = this.scanner;\n    let column = 1;\n    let excerpt = '';\n    let line = 1;\n\n    // Find the line and column where the error occurred.\n    for (let i = 0; i < charIndex; ++i) {\n      let char = xml[i];\n\n      if (char === '\\n') {\n        column = 1;\n        excerpt = '';\n        line += 1;\n      } else {\n        column += 1;\n        excerpt += char;\n      }\n    }\n\n    let eol = xml.indexOf('\\n', charIndex);\n\n    excerpt += eol === -1\n      ? xml.slice(charIndex)\n      : xml.slice(charIndex, eol);\n\n    let excerptStart = 0;\n\n    // Keep the excerpt below 50 chars, but always keep the error position in\n    // view.\n    if (excerpt.length > 50) {\n      if (column < 40) {\n        excerpt = excerpt.slice(0, 50);\n      } else {\n        excerptStart = column - 20;\n        excerpt = excerpt.slice(excerptStart, column + 30);\n      }\n    }\n\n    let err = new Error(\n      `${message} (line ${line}, column ${column})\\n`\n        + `  ${excerpt}\\n`\n        + ' '.repeat(column - excerptStart + 1) + '^\\n',\n    );\n\n    Object.assign(err, {\n      column,\n      excerpt,\n      line,\n      pos: charIndex,\n    });\n\n    return err;\n  }\n\n  /**\n   * Throws an invalid character error if any character in the given _string_\n   * isn't a valid XML character.\n   */\n  validateChars(string: string) {\n    let { length } = string;\n\n    for (let i = 0; i < length; ++i) {\n      let cp = string.codePointAt(i) as number;\n\n      if (!syntax.isXmlCodePoint(cp)) {\n        this.scanner.reset(-([ ...string ].length - i));\n        throw this.error('Invalid character');\n      }\n\n      if (cp > 65535) {\n        i += 1;\n      }\n    }\n  }\n}\n\n// -- Private Functions --------------------------------------------------------\n\n/**\n * Normalizes the given XML string by stripping a byte order mark (if present)\n * and replacing CRLF sequences and lone CR characters with LF characters.\n */\nfunction normalizeXmlString(xml: string): string {\n  if (xml[0] === '\\uFEFF') {\n    xml = xml.slice(1);\n  }\n\n  return xml.replace(/\\r\\n?/g, '\\n');\n}\n\n// -- Types --------------------------------------------------------------------\nexport type ParserOptions = {\n  /**\n   * When `true`, an undefined named entity (like \"&bogus;\") will be left in the\n   * output as is instead of causing a parse error.\n   *\n   * @default false\n   */\n  ignoreUndefinedEntities?: boolean;\n\n  /**\n   * When `true`, CDATA sections will be preserved in the document as `XmlCdata`\n   * nodes. Otherwise CDATA sections will be represented as `XmlText` nodes,\n   * which keeps the node tree simpler and easier to work with.\n   *\n   * @default false\n   */\n  preserveCdata?: boolean;\n\n  /**\n   * When `true`, comments will be preserved in the document as `XmlComment`\n   * nodes. Otherwise comments will not be included in the node tree.\n   *\n   * @default false\n   */\n  preserveComments?: boolean;\n\n  /**\n   * When an undefined named entity is encountered, this function will be called\n   * with the entity as its only argument. It should return a string value with\n   * which to replace the entity, or `null` or `undefined` to treat the entity\n   * as undefined (which may result in a parse error depending on the value of\n   * `ignoreUndefinedEntities`).\n   */\n  resolveUndefinedEntity?: (entity: string) => string | null | undefined;\n\n  /**\n   * When `true`, attributes in an element's `attributes` object will be sorted\n   * in alphanumeric order by name. Otherwise they'll retain their original\n   * order as found in the XML.\n   *\n   * @default false\n   */\n  sortAttributes?: boolean;\n};\n"],
  "mappings": "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",
  "names": ["charCount", "charLength", "charIndex", "multiByteMode", "charsToBytes", "isEnd", "charIndexToByteIndex", "advance", "consume", "peek", "consumeMatch", "consumeMatchFn", "consumeString", "consumeStringFast", "consumeUntilMatch", "consumeUntilString", "reset", "emptyString", "currentNode", "scanner", "consumeProlog", "consumeElement", "error", "consumeMisc", "isEnd", "addNode", "addText", "consumeAttributes", "consumeWhitespace", "consumeName", "consumeEqual", "consumeAttributeValue", "peek", "advance", "consumeMatch", "validateChars", "consumeReference", "consumeCdataSection", "consumeStringFast", "consumeUntilString", "consumeCharData", "consumeUntilMatch", "consumeComment", "consumeContentReference", "consumeDoctypeDeclaration", "charIndex", "reset", "consumeProcessingInstruction", "consumeMatchFn", "consumeXmlDeclaration", "consume", "consumeSystemLiteral"]
}
