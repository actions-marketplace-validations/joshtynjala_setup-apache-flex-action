/*! @rgrove/parse-xml v4.0.1 | ISC License | Copyright Ryan Grove */
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  XmlCdata: () => XmlCdata,
  XmlComment: () => XmlComment,
  XmlDocument: () => XmlDocument,
  XmlElement: () => XmlElement,
  XmlNode: () => XmlNode,
  XmlProcessingInstruction: () => XmlProcessingInstruction,
  XmlText: () => XmlText,
  parseXml: () => parseXml
});
module.exports = __toCommonJS(src_exports);

// src/lib/StringScanner.ts
var emptyString = "";
var surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
var StringScanner = class {
  constructor(string) {
    this.h = this.m(string, true);
    this.d = 0;
    this.length = string.length;
    this.j = this.h !== this.length;
    this.string = string;
    if (this.j) {
      let charsToBytes = [];
      for (let byteIndex = 0, charIndex = 0; charIndex < this.h; ++charIndex) {
        charsToBytes[charIndex] = byteIndex;
        byteIndex += string.codePointAt(byteIndex) > 65535 ? 2 : 1;
      }
      this.x = charsToBytes;
    }
  }
  get y() {
    return this.d >= this.h;
  }
  n(charIndex = this.d) {
    var _a;
    return this.j ? (_a = this.x[charIndex]) != null ? _a : Infinity : charIndex;
  }
  m(string, multiByteSafe = this.j) {
    return multiByteSafe ? string.replace(surrogatePair, "_").length : string.length;
  }
  f(count = 1) {
    this.d = Math.min(this.h, this.d + count);
  }
  D(count = 1) {
    let chars = this.g(count);
    this.f(count);
    return chars;
  }
  s(regex) {
    if (!regex.sticky) {
      throw new Error('`regex` must have a sticky flag ("y")');
    }
    regex.lastIndex = this.n();
    let result = regex.exec(this.string);
    if (result === null || result.length === 0) {
      return emptyString;
    }
    let match = result[0];
    this.f(this.m(match));
    return match;
  }
  t(fn) {
    let char;
    let match = emptyString;
    while ((char = this.g()) && fn(char)) {
      match += char;
      this.f();
    }
    return match;
  }
  N(stringToConsume) {
    if (this.b(stringToConsume)) {
      return stringToConsume;
    }
    if (this.j) {
      let { length } = stringToConsume;
      let charLengthToMatch = this.m(stringToConsume);
      if (charLengthToMatch !== length && stringToConsume === this.g(charLengthToMatch)) {
        this.f(charLengthToMatch);
        return stringToConsume;
      }
    }
    return emptyString;
  }
  b(stringToConsume) {
    let { length } = stringToConsume;
    if (this.g(length) === stringToConsume) {
      this.f(length);
      return stringToConsume;
    }
    return emptyString;
  }
  E(regex) {
    let restOfString = this.string.slice(this.n());
    let matchByteIndex = restOfString.search(regex);
    if (matchByteIndex <= 0) {
      return emptyString;
    }
    let result = restOfString.slice(0, matchByteIndex);
    this.f(this.m(result));
    return result;
  }
  p(searchString) {
    let { string } = this;
    let byteIndex = this.n();
    let matchByteIndex = string.indexOf(searchString, byteIndex);
    if (matchByteIndex <= 0) {
      return emptyString;
    }
    let result = string.slice(byteIndex, matchByteIndex);
    this.f(this.m(result));
    return result;
  }
  g(count = 1) {
    let { d: charIndex, j: multiByteMode, string } = this;
    if (multiByteMode) {
      if (charIndex >= this.h) {
        return emptyString;
      }
      return string.slice(
        this.n(charIndex),
        this.n(charIndex + count)
      );
    }
    return string.slice(charIndex, charIndex + count);
  }
  o(index = 0) {
    this.d = index >= 0 ? Math.min(this.h, index) : Math.max(0, this.d + index);
  }
};

// src/lib/syntax.ts
var attValueCharDoubleQuote = /[^"&<]+/y;
var attValueCharSingleQuote = /[^'&<]+/y;
var attValueNormalizedWhitespace = /[\t\n]/g;
var endCharData = /<|&|]]>/;
var predefinedEntities = Object.freeze(Object.assign(/* @__PURE__ */ Object.create(null), {
  amp: "&",
  apos: "'",
  gt: ">",
  lt: "<",
  quot: '"'
}));
function isNameChar(char) {
  let cp = getCodePoint(char);
  return cp >= 97 && cp <= 122 || cp >= 65 && cp <= 90 || cp >= 48 && cp <= 57 || cp === 45 || cp === 46 || cp === 183 || cp >= 768 && cp <= 879 || cp >= 8255 && cp <= 8256 || isNameStartChar(char, cp);
}
function isNameStartChar(char, cp = getCodePoint(char)) {
  return cp >= 97 && cp <= 122 || cp >= 65 && cp <= 90 || cp === 58 || cp === 95 || cp >= 192 && cp <= 214 || cp >= 216 && cp <= 246 || cp >= 248 && cp <= 767 || cp >= 880 && cp <= 893 || cp >= 895 && cp <= 8191 || cp >= 8204 && cp <= 8205 || cp >= 8304 && cp <= 8591 || cp >= 11264 && cp <= 12271 || cp >= 12289 && cp <= 55295 || cp >= 63744 && cp <= 64975 || cp >= 65008 && cp <= 65533 || cp >= 65536 && cp <= 983039;
}
function isReferenceChar(char) {
  return char === "#" || isNameChar(char);
}
function isWhitespace(char) {
  let cp = getCodePoint(char);
  return cp === 32 || cp === 9 || cp === 10 || cp === 13;
}
function isXmlCodePoint(cp) {
  return cp === 9 || cp === 10 || cp === 13 || cp >= 32 && cp <= 55295 || cp >= 57344 && cp <= 65533 || cp >= 65536 && cp <= 1114111;
}
function getCodePoint(char) {
  return char.codePointAt(0) || -1;
}

// src/lib/XmlNode.ts
var XmlNode = class {
  constructor() {
    this.parent = null;
  }
  get document() {
    var _a, _b;
    return (_b = (_a = this.parent) == null ? void 0 : _a.document) != null ? _b : null;
  }
  get isRootNode() {
    return this.parent !== null && this.parent === this.document;
  }
  get preserveWhitespace() {
    var _a;
    return Boolean((_a = this.parent) == null ? void 0 : _a.preserveWhitespace);
  }
  get type() {
    return "";
  }
  toJSON() {
    let json = {
      type: this.type
    };
    if (this.isRootNode) {
      json.isRootNode = true;
    }
    if (this.preserveWhitespace) {
      json.preserveWhitespace = true;
    }
    return json;
  }
};
XmlNode.TYPE_CDATA = "cdata";
XmlNode.TYPE_COMMENT = "comment";
XmlNode.TYPE_DOCUMENT = "document";
XmlNode.TYPE_ELEMENT = "element";
XmlNode.TYPE_PROCESSING_INSTRUCTION = "pi";
XmlNode.TYPE_TEXT = "text";

// src/lib/XmlText.ts
var XmlText = class extends XmlNode {
  constructor(text = "") {
    super();
    this.text = text;
  }
  get type() {
    return XmlNode.TYPE_TEXT;
  }
  toJSON() {
    return Object.assign(XmlNode.prototype.toJSON.call(this), {
      text: this.text
    });
  }
};

// src/lib/XmlCdata.ts
var XmlCdata = class extends XmlText {
  get type() {
    return XmlNode.TYPE_CDATA;
  }
};

// src/lib/XmlComment.ts
var XmlComment = class extends XmlNode {
  constructor(content = "") {
    super();
    this.content = content;
  }
  get type() {
    return XmlNode.TYPE_COMMENT;
  }
  toJSON() {
    return Object.assign(XmlNode.prototype.toJSON.call(this), {
      content: this.content
    });
  }
};

// src/lib/XmlElement.ts
var XmlElement = class extends XmlNode {
  constructor(name, attributes = /* @__PURE__ */ Object.create(null), children = []) {
    super();
    this.name = name;
    this.attributes = attributes;
    this.children = children;
  }
  get isEmpty() {
    return this.children.length === 0;
  }
  get preserveWhitespace() {
    let node = this;
    while (node instanceof XmlElement) {
      if ("xml:space" in node.attributes) {
        return node.attributes["xml:space"] === "preserve";
      }
      node = node.parent;
    }
    return false;
  }
  get text() {
    return this.children.map((child) => "text" in child ? child.text : "").join("");
  }
  get type() {
    return XmlNode.TYPE_ELEMENT;
  }
  toJSON() {
    return Object.assign(XmlNode.prototype.toJSON.call(this), {
      name: this.name,
      attributes: this.attributes,
      children: this.children.map((child) => child.toJSON())
    });
  }
};

// src/lib/XmlDocument.ts
var XmlDocument = class extends XmlNode {
  constructor(children = []) {
    super();
    this.children = children;
  }
  get document() {
    return this;
  }
  get root() {
    for (let child of this.children) {
      if (child instanceof XmlElement) {
        return child;
      }
    }
    return null;
  }
  get text() {
    return this.children.map((child) => "text" in child ? child.text : "").join("");
  }
  get type() {
    return XmlNode.TYPE_DOCUMENT;
  }
  toJSON() {
    return Object.assign(XmlNode.prototype.toJSON.call(this), {
      children: this.children.map((child) => child.toJSON())
    });
  }
};

// src/lib/XmlProcessingInstruction.ts
var XmlProcessingInstruction = class extends XmlNode {
  constructor(name, content = "") {
    super();
    this.name = name;
    this.content = content;
  }
  get type() {
    return XmlNode.TYPE_PROCESSING_INSTRUCTION;
  }
  toJSON() {
    return Object.assign(XmlNode.prototype.toJSON.call(this), {
      name: this.name,
      content: this.content
    });
  }
};

// src/lib/Parser.ts
var emptyString2 = "";
var Parser = class {
  constructor(xml, options = {}) {
    this.document = new XmlDocument();
    this.i = this.document;
    this.options = options;
    this.c = new StringScanner(normalizeXmlString(xml));
    this.F();
    if (!this.z()) {
      throw this.a("Root element is missing or invalid");
    }
    while (this.u()) {
    }
    if (!this.c.y) {
      throw this.a("Extra content at the end of the document");
    }
  }
  k(node) {
    node.parent = this.i;
    this.i.children.push(node);
  }
  v(text) {
    let { children } = this.i;
    let { length } = children;
    if (length > 0) {
      let prevNode = children[length - 1];
      if (prevNode instanceof XmlText) {
        prevNode.text += text;
        return;
      }
    }
    this.k(new XmlText(text));
  }
  G() {
    let attributes = /* @__PURE__ */ Object.create(null);
    while (this.e()) {
      let attrName = this.q();
      if (!attrName) {
        break;
      }
      let attrValue = this.r() && this.H();
      if (attrValue === false) {
        throw this.a("Attribute value expected");
      }
      if (attrName in attributes) {
        throw this.a(`Duplicate attribute: ${attrName}`);
      }
      if (attrName === "xml:space" && attrValue !== "default" && attrValue !== "preserve") {
        throw this.a('Value of the `xml:space` attribute must be "default" or "preserve"');
      }
      attributes[attrName] = attrValue;
    }
    if (this.options.sortAttributes) {
      let attrNames = Object.keys(attributes).sort();
      let sortedAttributes = /* @__PURE__ */ Object.create(null);
      for (let i = 0; i < attrNames.length; ++i) {
        let attrName = attrNames[i];
        sortedAttributes[attrName] = attributes[attrName];
      }
      attributes = sortedAttributes;
    }
    return attributes;
  }
  H() {
    let { c: scanner } = this;
    let quote = scanner.g();
    if (quote !== '"' && quote !== "'") {
      return false;
    }
    scanner.f();
    let chars;
    let isClosed = false;
    let value = emptyString2;
    let regex = quote === '"' ? attValueCharDoubleQuote : attValueCharSingleQuote;
    matchLoop:
      while (!scanner.y) {
        chars = scanner.s(regex);
        if (chars) {
          this.l(chars);
          value += chars.replace(attValueNormalizedWhitespace, " ");
        }
        switch (scanner.g()) {
          case quote:
            isClosed = true;
            break matchLoop;
          case "&":
            value += this.A();
            continue;
          case "<":
            throw this.a("Unescaped `<` is not allowed in an attribute value");
          case emptyString2:
            break matchLoop;
        }
      }
    if (!isClosed) {
      throw this.a("Unclosed attribute");
    }
    scanner.f();
    return value;
  }
  I() {
    let { c: scanner } = this;
    if (!scanner.b("<![CDATA[")) {
      return false;
    }
    let text = scanner.p("]]>");
    this.l(text);
    if (!scanner.b("]]>")) {
      throw this.a("Unclosed CDATA section");
    }
    if (this.options.preserveCdata) {
      this.k(new XmlCdata(text));
    } else {
      this.v(text);
    }
    return true;
  }
  J() {
    let { c: scanner } = this;
    let charData = scanner.E(endCharData);
    if (!charData) {
      return false;
    }
    this.l(charData);
    if (scanner.g(3) === "]]>") {
      throw this.a("Element content may not contain the CDATA section close delimiter `]]>`");
    }
    this.v(charData);
    return true;
  }
  B() {
    let { c: scanner } = this;
    if (!scanner.b("<!--")) {
      return false;
    }
    let content = scanner.p("--");
    this.l(content);
    if (!scanner.b("-->")) {
      if (scanner.g(2) === "--") {
        throw this.a("The string `--` isn't allowed inside a comment");
      }
      throw this.a("Unclosed comment");
    }
    if (this.options.preserveComments) {
      this.k(new XmlComment(content.trim()));
    }
    return true;
  }
  K() {
    let ref = this.A();
    if (ref) {
      this.v(ref);
      return true;
    }
    return false;
  }
  L() {
    let { c: scanner } = this;
    if (!scanner.b("<!DOCTYPE") || !this.e()) {
      return false;
    }
    scanner.s(/[^[>]+/y);
    if (scanner.s(/\[[\s\S]+?\][\x20\t\r\n]*>/y)) {
      return true;
    }
    if (!scanner.b(">")) {
      throw this.a("Unclosed doctype declaration");
    }
    return true;
  }
  z() {
    let { c: scanner } = this;
    let mark = scanner.d;
    if (!scanner.b("<")) {
      return false;
    }
    let name = this.q();
    if (!name) {
      scanner.o(mark);
      return false;
    }
    let attributes = this.G();
    let isEmpty = Boolean(scanner.b("/>"));
    let element = new XmlElement(name, attributes);
    element.parent = this.i;
    if (!isEmpty) {
      if (!scanner.b(">")) {
        throw this.a(`Unclosed start tag for element \`${name}\``);
      }
      this.i = element;
      do {
        this.J();
      } while (this.z() || this.K() || this.I() || this.C() || this.B());
      let endTagMark = scanner.d;
      let endTagName;
      if (!scanner.b("</") || !(endTagName = this.q()) || endTagName !== name) {
        scanner.o(endTagMark);
        throw this.a(`Missing end tag for element ${name}`);
      }
      this.e();
      if (!scanner.b(">")) {
        throw this.a(`Unclosed end tag for element ${name}`);
      }
      this.i = element.parent;
    }
    this.k(element);
    return true;
  }
  r() {
    this.e();
    if (this.c.b("=")) {
      this.e();
      return true;
    }
    return false;
  }
  u() {
    return this.B() || this.C() || this.e();
  }
  q() {
    return isNameStartChar(this.c.g()) ? this.c.t(isNameChar) : emptyString2;
  }
  C() {
    let { c: scanner } = this;
    let mark = scanner.d;
    if (!scanner.b("<?")) {
      return false;
    }
    let name = this.q();
    if (name) {
      if (name.toLowerCase() === "xml") {
        scanner.o(mark);
        throw this.a("XML declaration isn't allowed here");
      }
    } else {
      throw this.a("Invalid processing instruction");
    }
    if (!this.e()) {
      if (scanner.b("?>")) {
        this.k(new XmlProcessingInstruction(name));
        return true;
      }
      throw this.a("Whitespace is required after a processing instruction name");
    }
    let content = scanner.p("?>");
    this.l(content);
    if (!scanner.b("?>")) {
      throw this.a("Unterminated processing instruction");
    }
    this.k(new XmlProcessingInstruction(name, content));
    return true;
  }
  F() {
    let { c: scanner } = this;
    let mark = scanner.d;
    this.M();
    while (this.u()) {
    }
    if (this.L()) {
      while (this.u()) {
      }
    }
    return mark < scanner.d;
  }
  A() {
    let { c: scanner } = this;
    if (!scanner.b("&")) {
      return false;
    }
    let ref = scanner.t(isReferenceChar);
    if (scanner.D() !== ";") {
      throw this.a("Unterminated reference (a reference must end with `;`)");
    }
    let parsedValue;
    if (ref[0] === "#") {
      let codePoint = ref[1] === "x" ? parseInt(ref.slice(2), 16) : parseInt(ref.slice(1), 10);
      if (isNaN(codePoint)) {
        throw this.a("Invalid character reference");
      }
      if (!isXmlCodePoint(codePoint)) {
        throw this.a("Character reference resolves to an invalid character");
      }
      parsedValue = String.fromCodePoint(codePoint);
    } else {
      parsedValue = predefinedEntities[ref];
      if (parsedValue === void 0) {
        let {
          ignoreUndefinedEntities,
          resolveUndefinedEntity
        } = this.options;
        let wrappedRef = `&${ref};`;
        if (resolveUndefinedEntity) {
          let resolvedValue = resolveUndefinedEntity(wrappedRef);
          if (resolvedValue !== null && resolvedValue !== void 0) {
            let type = typeof resolvedValue;
            if (type !== "string") {
              throw new TypeError(`\`resolveUndefinedEntity()\` must return a string, \`null\`, or \`undefined\`, but returned a value of type ${type}`);
            }
            return resolvedValue;
          }
        }
        if (ignoreUndefinedEntities) {
          return wrappedRef;
        }
        scanner.o(-wrappedRef.length);
        throw this.a(`Named entity isn't defined: ${wrappedRef}`);
      }
    }
    return parsedValue;
  }
  w() {
    let { c: scanner } = this;
    let quote = scanner.b('"') || scanner.b("'");
    if (!quote) {
      return false;
    }
    let value = scanner.p(quote);
    this.l(value);
    if (!scanner.b(quote)) {
      throw this.a("Missing end quote");
    }
    return value;
  }
  e() {
    return Boolean(this.c.t(isWhitespace));
  }
  M() {
    let { c: scanner } = this;
    if (!scanner.b("<?xml")) {
      return false;
    }
    if (!this.e()) {
      throw this.a("Invalid XML declaration");
    }
    let version = Boolean(scanner.b("version")) && this.r() && this.w();
    if (version === false) {
      throw this.a("XML version is missing or invalid");
    } else if (!/^1\.[0-9]+$/.test(version)) {
      throw this.a("Invalid character in version number");
    }
    if (this.e()) {
      let encoding = Boolean(scanner.b("encoding")) && this.r() && this.w();
      if (encoding) {
        this.e();
      }
      let standalone = Boolean(scanner.b("standalone")) && this.r() && this.w();
      if (standalone) {
        if (standalone !== "yes" && standalone !== "no") {
          throw this.a('Only "yes" and "no" are permitted as values of `standalone`');
        }
        this.e();
      }
    }
    if (!scanner.b("?>")) {
      throw this.a("Invalid or unclosed XML declaration");
    }
    return true;
  }
  a(message) {
    let { d: charIndex, string: xml } = this.c;
    let column = 1;
    let excerpt = "";
    let line = 1;
    for (let i = 0; i < charIndex; ++i) {
      let char = xml[i];
      if (char === "\n") {
        column = 1;
        excerpt = "";
        line += 1;
      } else {
        column += 1;
        excerpt += char;
      }
    }
    let eol = xml.indexOf("\n", charIndex);
    excerpt += eol === -1 ? xml.slice(charIndex) : xml.slice(charIndex, eol);
    let excerptStart = 0;
    if (excerpt.length > 50) {
      if (column < 40) {
        excerpt = excerpt.slice(0, 50);
      } else {
        excerptStart = column - 20;
        excerpt = excerpt.slice(excerptStart, column + 30);
      }
    }
    let err = new Error(
      `${message} (line ${line}, column ${column})
  ${excerpt}
` + " ".repeat(column - excerptStart + 1) + "^\n"
    );
    Object.assign(err, {
      column,
      excerpt,
      line,
      pos: charIndex
    });
    return err;
  }
  l(string) {
    let { length } = string;
    for (let i = 0; i < length; ++i) {
      let cp = string.codePointAt(i);
      if (!isXmlCodePoint(cp)) {
        this.c.o(-([...string].length - i));
        throw this.a("Invalid character");
      }
      if (cp > 65535) {
        i += 1;
      }
    }
  }
};
function normalizeXmlString(xml) {
  if (xml[0] === "\uFEFF") {
    xml = xml.slice(1);
  }
  return xml.replace(/\r\n?/g, "\n");
}

// src/index.ts
function parseXml(xml, options) {
  return new Parser(xml, options).document;
}
//# sourceMappingURL=browser.js.map
