{
  "version": 3,
  "sources": ["../src/index.ts", "../src/lib/StringScanner.ts", "../src/lib/syntax.ts", "../src/lib/XmlNode.ts", "../src/lib/XmlText.ts", "../src/lib/XmlCdata.ts", "../src/lib/XmlComment.ts", "../src/lib/XmlElement.ts", "../src/lib/XmlDocument.ts", "../src/lib/XmlProcessingInstruction.ts", "../src/lib/Parser.ts"],
  "sourcesContent": ["import { Parser } from './lib/Parser.js';\n\nimport type { ParserOptions } from './lib/Parser.js';\n\nexport * from './lib/types.js';\nexport { XmlCdata } from './lib/XmlCdata.js';\nexport { XmlComment } from './lib/XmlComment.js';\nexport { XmlDocument } from './lib/XmlDocument.js';\nexport { XmlElement } from './lib/XmlElement.js';\nexport { XmlNode } from './lib/XmlNode.js';\nexport { XmlProcessingInstruction } from './lib/XmlProcessingInstruction.js';\nexport { XmlText } from './lib/XmlText.js';\n\nexport type { ParserOptions } from './lib/Parser.js';\n\n/**\n * Parses the given XML string and returns an `XmlDocument` instance\n * representing the document tree.\n *\n * @example\n *\n * import { parseXml } from '@rgrove/parse-xml';\n * let doc = parseXml('<kittens fuzzy=\"yes\">I like fuzzy kittens.</kittens>');\n *\n * @param xml XML string to parse.\n * @param options Parser options.\n */\nexport function parseXml(xml: string, options?: ParserOptions) {\n  return (new Parser(xml, options)).document;\n}\n", "const emptyString = '';\nconst surrogatePair = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n\n/** @private */\nexport class StringScanner {\n  charIndex: number;\n  readonly string: string;\n\n  private readonly charCount: number;\n  private readonly charsToBytes: number[] | undefined;\n  private readonly length: number;\n  private readonly multiByteMode: boolean;\n\n  constructor(string: string) {\n    this.charCount = this.charLength(string, true);\n    this.charIndex = 0;\n    this.length = string.length;\n    this.multiByteMode = this.charCount !== this.length;\n    this.string = string;\n\n    if (this.multiByteMode) {\n      let charsToBytes = [];\n\n      // Create a mapping of character indexes to byte indexes. Since the string\n      // contains multibyte characters, a byte index may not necessarily align\n      // with a character index.\n      for (let byteIndex = 0, charIndex = 0; charIndex < this.charCount; ++charIndex) {\n        charsToBytes[charIndex] = byteIndex;\n        byteIndex += (string.codePointAt(byteIndex) as number) > 65535 ? 2 : 1;\n      }\n\n      this.charsToBytes = charsToBytes;\n    }\n  }\n\n  /**\n   * Whether the current character index is at the end of the input string.\n   */\n  get isEnd() {\n    return this.charIndex >= this.charCount;\n  }\n\n  // -- Protected Methods ------------------------------------------------------\n\n  /**\n   * Returns the byte index of the given character index in the string. The two\n   * may differ in strings that contain multibyte characters.\n   */\n  protected charIndexToByteIndex(charIndex: number = this.charIndex): number {\n    return this.multiByteMode\n      ? (this.charsToBytes as number[])[charIndex] ?? Infinity\n      : charIndex;\n  }\n\n  /**\n   * Returns the number of characters in the given string, which may differ from\n   * the byte length if the string contains multibyte characters.\n   */\n  protected charLength(string: string, multiByteSafe = this.multiByteMode): number {\n    // We could get the char length with `[ ...string ].length`, but that's\n    // actually slower than replacing surrogate pairs with single-byte\n    // characters and then counting the result.\n    return multiByteSafe\n      ? string.replace(surrogatePair, '_').length\n      : string.length;\n  }\n\n  // -- Public Methods ---------------------------------------------------------\n\n  /**\n   * Advances the scanner by the given number of characters, stopping if the end\n   * of the string is reached.\n   */\n  advance(count = 1) {\n    this.charIndex = Math.min(this.charCount, this.charIndex + count);\n  }\n\n  /**\n   * Consumes and returns the given number of characters if possible, advancing\n   * the scanner and stopping if the end of the string is reached.\n   *\n   * If no characters could be consumed, an empty string will be returned.\n   */\n  consume(count = 1): string {\n    let chars = this.peek(count);\n    this.advance(count);\n    return chars;\n  }\n\n  /**\n   * Consumes a match for the given sticky regex, advances the scanner, updates\n   * the `lastIndex` property of the regex, and returns the matching string.\n   *\n   * The regex must have a sticky flag (\"y\") so that its `lastIndex` prop can be\n   * used to anchor the match at the current scanner position.\n   *\n   * Returns the consumed string, or an empty string if nothing was consumed.\n   */\n  consumeMatch(regex: RegExp): string {\n    if (!regex.sticky) {\n      throw new Error('`regex` must have a sticky flag (\"y\")');\n    }\n\n    regex.lastIndex = this.charIndexToByteIndex();\n\n    let result = regex.exec(this.string);\n\n    if (result === null || result.length === 0) {\n      return emptyString;\n    }\n\n    let match = result[0] as string;\n    this.advance(this.charLength(match));\n    return match;\n  }\n\n  /**\n   * Consumes and returns all characters for which the given function returns a\n   * truthy value, stopping on the first falsy return value or if the end of the\n   * input is reached.\n   */\n  consumeMatchFn(fn: (char: string) => boolean): string {\n    let char;\n    let match = emptyString;\n\n    while ((char = this.peek()) && fn(char)) {\n      match += char;\n      this.advance();\n    }\n\n    return match;\n  }\n\n  /**\n   * Consumes the given string if it exists at the current character index, and\n   * advances the scanner.\n   *\n   * If the given string doesn't exist at the current character index, an empty\n   * string will be returned and the scanner will not be advanced.\n   */\n  consumeString(stringToConsume: string): string {\n    if (this.consumeStringFast(stringToConsume)) {\n      return stringToConsume;\n    }\n\n    if (this.multiByteMode) {\n      let { length } = stringToConsume;\n      let charLengthToMatch = this.charLength(stringToConsume);\n\n      if (charLengthToMatch !== length\n          && stringToConsume === this.peek(charLengthToMatch)) {\n\n        this.advance(charLengthToMatch);\n        return stringToConsume;\n      }\n    }\n\n    return emptyString;\n  }\n\n  /**\n   * Does the same thing as `consumeString()`, but doesn't support consuming\n   * multibyte characters. This can be faster if you only need to match single\n   * byte characters.\n   */\n  consumeStringFast(stringToConsume: string): string {\n    let { length } = stringToConsume;\n\n    if (this.peek(length) === stringToConsume) {\n      this.advance(length);\n      return stringToConsume;\n    }\n\n    return emptyString;\n  }\n\n  /**\n   * Consumes characters until the given global regex is matched, advancing the\n   * scanner up to (but not beyond) the beginning of the match. If the regex\n   * doesn't match, nothing will be consumed.\n   *\n   * Returns the consumed string, or an empty string if nothing was consumed.\n   */\n  consumeUntilMatch(regex: RegExp): string {\n    let restOfString = this.string.slice(this.charIndexToByteIndex());\n    let matchByteIndex = restOfString.search(regex);\n\n    if (matchByteIndex <= 0) {\n      return emptyString;\n    }\n\n    let result = restOfString.slice(0, matchByteIndex);\n    this.advance(this.charLength(result));\n    return result;\n  }\n\n  /**\n   * Consumes characters until the given string is found, advancing the scanner\n   * up to (but not beyond) that point. If the string is never found, nothing\n   * will be consumed.\n   *\n   * Returns the consumed string, or an empty string if nothing was consumed.\n   */\n  consumeUntilString(searchString: string): string {\n    let { string } = this;\n    let byteIndex = this.charIndexToByteIndex();\n    let matchByteIndex = string.indexOf(searchString, byteIndex);\n\n    if (matchByteIndex <= 0) {\n      return emptyString;\n    }\n\n    let result = string.slice(byteIndex, matchByteIndex);\n    this.advance(this.charLength(result));\n    return result;\n  }\n\n  /**\n   * Returns the given number of characters starting at the current character\n   * index, without advancing the scanner and without exceeding the end of the\n   * input string.\n   */\n  peek(count = 1): string {\n    let { charIndex, multiByteMode, string } = this;\n\n    if (multiByteMode) {\n      // Inlining this comparison instead of checking `this.isEnd` improves perf\n      // slightly since `peek()` is called so frequently.\n      if (charIndex >= this.charCount) {\n        return emptyString;\n      }\n\n      return string.slice(\n        this.charIndexToByteIndex(charIndex),\n        this.charIndexToByteIndex(charIndex + count),\n      );\n    }\n\n    return string.slice(charIndex, charIndex + count);\n  }\n\n  /**\n   * Resets the scanner position to the given character _index_, or to the start\n   * of the input string if no index is given.\n   *\n   * If _index_ is negative, the scanner position will be moved backward by that\n   * many characters, stopping if the beginning of the string is reached.\n   */\n  reset(index = 0) {\n    this.charIndex = index >= 0\n      ? Math.min(this.charCount, index)\n      : Math.max(0, this.charIndex + index);\n  }\n}\n", "/**\n * Regular expression that matches one or more `AttValue` characters in a\n * double-quoted attribute value.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-AttValue\n */\nexport const attValueCharDoubleQuote = /[^\"&<]+/y;\n\n/**\n * Regular expression that matches one or more `AttValue` characters in a\n * single-quoted attribute value.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-AttValue\n */\nexport const attValueCharSingleQuote = /[^'&<]+/y;\n\n/**\n * Regular expression that matches a whitespace character that should be\n * normalized to a space character in an attribute value.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#AVNormalize\n */\nexport const attValueNormalizedWhitespace = /[\\t\\n]/g;\n\n/**\n * Regular expression that matches one or more characters that signal the end of\n * XML `CharData` content.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#dt-chardata\n */\nexport const endCharData = /<|&|]]>/;\n\n/**\n * Mapping of predefined entity names to their replacement values.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-predefined-ent\n */\nexport const predefinedEntities: Readonly<{[name: string]: string;}> = Object.freeze(Object.assign(Object.create(null), {\n  amp: '&',\n  apos: \"'\",\n  gt: '>',\n  lt: '<',\n  quot: '\"',\n}));\n\n/**\n * Returns `true` if _char_ is an XML `NameChar`, `false` if it isn't.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-NameChar\n */\nexport function isNameChar(char: string): boolean {\n  let cp = getCodePoint(char);\n\n  // Including the most common NameStartChars here improves performance\n  // slightly.\n  return (cp >= 0x61 && cp <= 0x7A) // a-z\n    || (cp >= 0x41 && cp <= 0x5A) // A-Z\n    || (cp >= 0x30 && cp <= 0x39) // 0-9\n    || cp === 0x2D // -\n    || cp === 0x2E // .\n    || cp === 0xB7\n    || (cp >= 0x300 && cp <= 0x36F)\n    || (cp >= 0x203F && cp <= 0x2040)\n    || isNameStartChar(char, cp);\n}\n\n/**\n * Returns `true` if _char_ is an XML `NameStartChar`, `false` if it isn't.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-NameStartChar\n */\nexport function isNameStartChar(char: string, cp = getCodePoint(char)): boolean {\n  return (cp >= 0x61 && cp <= 0x7A) // a-z\n    || (cp >= 0x41 && cp <= 0x5A) // A-Z\n    || cp === 0x3A // :\n    || cp === 0x5F // _\n    || (cp >= 0xC0 && cp <= 0xD6)\n    || (cp >= 0xD8 && cp <= 0xF6)\n    || (cp >= 0xF8 && cp <= 0x2FF)\n    || (cp >= 0x370 && cp <= 0x37D)\n    || (cp >= 0x37F && cp <= 0x1FFF)\n    || (cp >= 0x200C && cp <= 0x200D)\n    || (cp >= 0x2070 && cp <= 0x218F)\n    || (cp >= 0x2C00 && cp <= 0x2FEF)\n    || (cp >= 0x3001 && cp <= 0xD7FF)\n    || (cp >= 0xF900 && cp <= 0xFDCF)\n    || (cp >= 0xFDF0 && cp <= 0xFFFD)\n    || (cp >= 0x10000 && cp <= 0xEFFFF);\n}\n\n/**\n * Returns `true` if _char_ is a valid reference character (which may appear\n * between `&` and `;` in a reference), `false` otherwise.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-references\n */\nexport function isReferenceChar(char: string): boolean {\n  return char === '#' || isNameChar(char);\n}\n\n/**\n * Returns `true` if _char_ is an XML whitespace character, `false` otherwise.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#white\n */\nexport function isWhitespace(char: string): boolean {\n  let cp = getCodePoint(char);\n\n  return cp === 0x20\n    || cp === 0x9\n    || cp === 0xA\n    || cp === 0xD;\n}\n\n/**\n * Returns `true` if _codepoint_ is a valid XML `Char` code point, `false`\n * otherwise.\n *\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Char\n */\nexport function isXmlCodePoint(cp: number): boolean {\n  return cp === 0x9\n    || cp === 0xA\n    || cp === 0xD\n    || (cp >= 0x20 && cp <= 0xD7FF)\n    || (cp >= 0xE000 && cp <= 0xFFFD)\n    || (cp >= 0x10000 && cp <= 0x10FFFF);\n}\n\n/**\n * Returns the Unicode code point value of the given character, or `-1` if\n * _char_ is empty.\n */\nfunction getCodePoint(char: string): number {\n  return char.codePointAt(0) || -1;\n}\n", "import type { JsonObject } from './types.js';\nimport type { XmlDocument } from './XmlDocument.js';\nimport type { XmlElement } from './XmlElement.js';\n\n/**\n * Base interface for a node in an XML document.\n */\nexport class XmlNode {\n  /**\n   * Type value for an `XmlCdata` node.\n   */\n  static readonly TYPE_CDATA = 'cdata';\n\n  /**\n   * Type value for an `XmlComment` node.\n   */\n  static readonly TYPE_COMMENT = 'comment';\n\n  /**\n   * Type value for an `XmlDocument` node.\n   */\n  static readonly TYPE_DOCUMENT = 'document';\n\n  /**\n   * Type value for an `XmlElement` node.\n   */\n  static readonly TYPE_ELEMENT = 'element';\n\n  /**\n   * Type value for an `XmlProcessingInstruction` node.\n   */\n  static readonly TYPE_PROCESSING_INSTRUCTION = 'pi';\n\n  /**\n   * Type value for an `XmlText` node.\n   */\n  static readonly TYPE_TEXT = 'text';\n\n  /**\n   * Parent node of this node, or `null` if this node has no parent.\n   */\n  parent: XmlDocument | XmlElement | null = null;\n\n  /**\n   * Document that contains this node, or `null` if this node is not associated\n   * with a document.\n   */\n  get document(): XmlDocument | null {\n    return this.parent?.document ?? null;\n  }\n\n  /**\n   * Whether this node is the root node of the document.\n   */\n  get isRootNode(): boolean {\n    return this.parent !== null && this.parent === this.document;\n  }\n\n  /**\n   * Whether whitespace should be preserved in the content of this element and\n   * its children.\n   *\n   * This is influenced by the value of the special `xml:space` attribute, and\n   * will be `true` for any node whose `xml:space` attribute is set to\n   * \"preserve\". If a node has no such attribute, it will inherit the value of\n   * the nearest ancestor that does (if any).\n   *\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-white-space\n   */\n  get preserveWhitespace(): boolean {\n    return Boolean(this.parent?.preserveWhitespace);\n  }\n\n  /**\n   * Type of this node.\n   *\n   * The value of this property is a string that matches one of the static\n   * `TYPE_*` properties on the `XmlNode` class (e.g. `TYPE_ELEMENT`,\n   * `TYPE_TEXT`, etc.).\n   *\n   * The `XmlNode` class itself is a base class and doesn't have its own type\n   * name.\n   */\n  get type() {\n    return '';\n  }\n\n  /**\n   * Returns a JSON-serializable object representing this node, minus properties\n   * that could result in circular references.\n   */\n  toJSON(): JsonObject {\n    let json: JsonObject = {\n      type: this.type,\n    };\n\n    if (this.isRootNode) {\n      json.isRootNode = true;\n    }\n\n    if (this.preserveWhitespace) {\n      json.preserveWhitespace = true;\n    }\n\n    return json;\n  }\n}\n", "import { XmlNode } from './XmlNode.js';\n\n/**\n * Text content within an XML document.\n */\nexport class XmlText extends XmlNode {\n  /**\n   * Text content of this node.\n   */\n  text: string;\n\n  constructor(text = '') {\n    super();\n    this.text = text;\n  }\n\n  override get type() {\n    return XmlNode.TYPE_TEXT;\n  }\n\n  override toJSON() {\n    return Object.assign(XmlNode.prototype.toJSON.call(this), {\n      text: this.text,\n    });\n  }\n}\n", "import { XmlNode } from './XmlNode.js';\nimport { XmlText } from './XmlText.js';\n\n/**\n * A CDATA section within an XML document.\n */\nexport class XmlCdata extends XmlText {\n  override get type() {\n    return XmlNode.TYPE_CDATA;\n  }\n}\n", "import { XmlNode } from './XmlNode.js';\n\n/**\n * A comment within an XML document.\n */\nexport class XmlComment extends XmlNode {\n  /**\n   * Content of this comment.\n   */\n  content: string;\n\n  constructor(content = '') {\n    super();\n    this.content = content;\n  }\n\n  override get type() {\n    return XmlNode.TYPE_COMMENT;\n  }\n\n  override toJSON() {\n    return Object.assign(XmlNode.prototype.toJSON.call(this), {\n      content: this.content,\n    });\n  }\n}\n", "import { XmlNode } from './XmlNode.js';\n\nimport type { JsonObject } from './types.js';\nimport type { XmlCdata } from './XmlCdata.js';\nimport type { XmlComment } from './XmlComment.js';\nimport type { XmlProcessingInstruction } from './XmlProcessingInstruction.js';\nimport type { XmlText } from './XmlText.js';\n\n/**\n * Element in an XML document.\n */\nexport class XmlElement extends XmlNode {\n  /**\n   * Attributes on this element.\n   */\n  attributes: {[attrName: string]: string};\n\n  /**\n   * Child nodes of this element.\n   */\n  children: Array<XmlCdata | XmlComment | XmlElement | XmlProcessingInstruction | XmlText>;\n\n  /**\n   * Name of this element.\n   */\n  name: string;\n\n  constructor(\n    name: string,\n    attributes: {[attrName: string]: string} = Object.create(null),\n    children: Array<XmlCdata | XmlComment | XmlElement | XmlProcessingInstruction | XmlText> = [],\n  ) {\n    super();\n\n    this.name = name;\n    this.attributes = attributes;\n    this.children = children;\n  }\n\n  /**\n   * Whether this element is empty (meaning it has no children).\n   */\n  get isEmpty(): boolean {\n    return this.children.length === 0;\n  }\n\n  override get preserveWhitespace(): boolean {\n    let node: XmlNode | null = this; // eslint-disable-line @typescript-eslint/no-this-alias\n\n    while (node instanceof XmlElement) {\n      if ('xml:space' in node.attributes) {\n        return node.attributes['xml:space'] === 'preserve';\n      }\n\n      node = node.parent;\n    }\n\n    return false;\n  }\n\n  /**\n   * Text content of this element and all its descendants.\n   */\n  get text(): string {\n    return this.children\n      .map(child => 'text' in child ? child.text : '')\n      .join('');\n  }\n\n  override get type() {\n    return XmlNode.TYPE_ELEMENT;\n  }\n\n  override toJSON(): JsonObject {\n    return Object.assign(XmlNode.prototype.toJSON.call(this), {\n      name: this.name,\n      attributes: this.attributes,\n      children: this.children.map(child => child.toJSON()),\n    });\n  }\n}\n", "import { XmlElement } from './XmlElement.js';\nimport { XmlNode } from './XmlNode.js';\n\nimport type { XmlComment } from './XmlComment.js';\nimport type { XmlProcessingInstruction } from './XmlProcessingInstruction.js';\n\n/**\n * Represents an XML document. All elements within the document are descendants\n * of this node.\n */\nexport class XmlDocument extends XmlNode {\n  /**\n   * Child nodes of this document.\n   */\n  readonly children: Array<XmlComment | XmlProcessingInstruction | XmlElement>;\n\n  constructor(children: Array<XmlComment | XmlElement | XmlProcessingInstruction> = []) {\n    super();\n    this.children = children;\n  }\n\n  override get document() {\n    return this;\n  }\n\n  /**\n   * Root element of this document, or `null` if this document is empty.\n   */\n  get root(): XmlElement | null {\n    for (let child of this.children) {\n      if (child instanceof XmlElement) {\n        return child;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Text content of this document and all its descendants.\n   */\n  get text(): string {\n    return this.children\n      .map(child => 'text' in child ? child.text : '')\n      .join('');\n  }\n\n  override get type() {\n    return XmlNode.TYPE_DOCUMENT;\n  }\n\n  override toJSON() {\n    return Object.assign(XmlNode.prototype.toJSON.call(this), {\n      children: this.children.map(child => child.toJSON()),\n    });\n  }\n}\n", "import { XmlNode } from './XmlNode.js';\n\n/**\n * A processing instruction within an XML document.\n */\nexport class XmlProcessingInstruction extends XmlNode {\n  /**\n   * Content of this processing instruction.\n   */\n  content: string;\n\n  /**\n   * Name of this processing instruction. Also sometimes referred to as the\n   * processing instruction \"target\".\n   */\n  name: string;\n\n  constructor(name: string, content = '') {\n    super();\n\n    this.name = name;\n    this.content = content;\n  }\n\n  override get type() {\n    return XmlNode.TYPE_PROCESSING_INSTRUCTION;\n  }\n\n  override toJSON() {\n    return Object.assign(XmlNode.prototype.toJSON.call(this), {\n      name: this.name,\n      content: this.content,\n    });\n  }\n}\n", "import { StringScanner } from './StringScanner.js';\nimport * as syntax from './syntax.js';\nimport { XmlCdata } from './XmlCdata.js';\nimport { XmlComment } from './XmlComment.js';\nimport { XmlDocument } from './XmlDocument.js';\nimport { XmlElement } from './XmlElement.js';\nimport { XmlProcessingInstruction } from './XmlProcessingInstruction.js';\nimport { XmlText } from './XmlText.js';\n\nimport type { XmlNode } from './XmlNode.js';\n\n\nconst emptyString = '';\n\n/**\n * Parses an XML string into an `XmlDocument`.\n *\n * @private\n */\nexport class Parser {\n  readonly document: XmlDocument;\n\n  private currentNode: XmlDocument | XmlElement;\n  private readonly options: ParserOptions;\n  private readonly scanner: StringScanner;\n\n  /**\n   * @param xml XML string to parse.\n   * @param options Parser options.\n   */\n  constructor(xml: string, options: ParserOptions = {}) {\n    this.document = new XmlDocument();\n    this.currentNode = this.document;\n    this.options = options;\n    this.scanner = new StringScanner(normalizeXmlString(xml));\n\n    this.consumeProlog();\n\n    if (!this.consumeElement()) {\n      throw this.error('Root element is missing or invalid');\n    }\n\n    while (this.consumeMisc()) {} // eslint-disable-line no-empty\n\n    if (!this.scanner.isEnd) {\n      throw this.error('Extra content at the end of the document');\n    }\n  }\n\n  /**\n   * Adds the given `XmlNode` as a child of `this.currentNode`.\n   */\n  addNode(node: XmlNode) {\n    node.parent = this.currentNode;\n\n    // @ts-expect-error: XmlDocument has a more limited set of possible children\n    // than XmlElement so TypeScript is unhappy, but we always do the right\n    // thing.\n    this.currentNode.children.push(node);\n  }\n\n  /**\n   * Adds the given _text_ to the document, either by appending it to a\n   * preceding `XmlText` node (if possible) or by creating a new `XmlText` node.\n   */\n  addText(text: string) {\n    let { children } = this.currentNode;\n    let { length } = children;\n\n    if (length > 0) {\n      let prevNode = children[length - 1];\n\n      if (prevNode instanceof XmlText) {\n        // The previous node is a text node, so we can append to it and avoid\n        // creating another node.\n        prevNode.text += text;\n        return;\n      }\n    }\n\n    this.addNode(new XmlText(text));\n  }\n\n  /**\n   * Consumes element attributes.\n   *\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-starttags\n   */\n  consumeAttributes(): Record<string, string> {\n    let attributes = Object.create(null);\n\n    while (this.consumeWhitespace()) {\n      let attrName = this.consumeName();\n\n      if (!attrName) {\n        break;\n      }\n\n      let attrValue = this.consumeEqual() && this.consumeAttributeValue();\n\n      if (attrValue === false) {\n        throw this.error('Attribute value expected');\n      }\n\n      if (attrName in attributes) {\n        throw this.error(`Duplicate attribute: ${attrName}`);\n      }\n\n      if (attrName === 'xml:space'\n          && attrValue !== 'default'\n          && attrValue !== 'preserve') {\n\n        throw this.error('Value of the `xml:space` attribute must be \"default\" or \"preserve\"');\n      }\n\n      attributes[attrName] = attrValue;\n    }\n\n    if (this.options.sortAttributes) {\n      let attrNames = Object.keys(attributes).sort();\n      let sortedAttributes = Object.create(null);\n\n      for (let i = 0; i < attrNames.length; ++i) {\n        let attrName = attrNames[i] as string;\n        sortedAttributes[attrName] = attributes[attrName];\n      }\n\n      attributes = sortedAttributes;\n    }\n\n    return attributes;\n  }\n\n  /**\n   * Consumes an `AttValue` (attribute value) if possible.\n   *\n   * @returns\n   *   Contents of the `AttValue` minus quotes, or `false` if nothing was\n   *   consumed. An empty string indicates that an `AttValue` was consumed but\n   *   was empty.\n   *\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-AttValue\n   */\n  consumeAttributeValue(): string | false {\n    let { scanner } = this;\n    let quote = scanner.peek();\n\n    if (quote !== '\"' && quote !== \"'\") {\n      return false;\n    }\n\n    scanner.advance();\n\n    let chars;\n    let isClosed = false;\n    let value = emptyString;\n    let regex = quote === '\"'\n      ? syntax.attValueCharDoubleQuote\n      : syntax.attValueCharSingleQuote;\n\n    matchLoop: while (!scanner.isEnd) {\n      chars = scanner.consumeMatch(regex);\n\n      if (chars) {\n        this.validateChars(chars);\n        value += chars.replace(syntax.attValueNormalizedWhitespace, ' ');\n      }\n\n      switch (scanner.peek()) {\n        case quote:\n          isClosed = true;\n          break matchLoop;\n\n        case '&':\n          value += this.consumeReference();\n          continue;\n\n        case '<':\n          throw this.error('Unescaped `<` is not allowed in an attribute value');\n\n        case emptyString:\n          break matchLoop;\n      }\n    }\n\n    if (!isClosed) {\n      throw this.error('Unclosed attribute');\n    }\n\n    scanner.advance();\n    return value;\n  }\n\n  /**\n   * Consumes a CDATA section if possible.\n   *\n   * @returns Whether a CDATA section was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-cdata-sect\n   */\n  consumeCdataSection(): boolean {\n    let { scanner } = this;\n\n    if (!scanner.consumeStringFast('<![CDATA[')) {\n      return false;\n    }\n\n    let text = scanner.consumeUntilString(']]>');\n    this.validateChars(text);\n\n    if (!scanner.consumeStringFast(']]>')) {\n      throw this.error('Unclosed CDATA section');\n    }\n\n    if (this.options.preserveCdata) {\n      this.addNode(new XmlCdata(text));\n    } else {\n      this.addText(text);\n    }\n\n    return true;\n  }\n\n  /**\n   * Consumes character data if possible.\n   *\n   * @returns Whether character data was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#dt-chardata\n   */\n  consumeCharData(): boolean {\n    let { scanner } = this;\n    let charData = scanner.consumeUntilMatch(syntax.endCharData);\n\n    if (!charData) {\n      return false;\n    }\n\n    this.validateChars(charData);\n\n    if (scanner.peek(3) === ']]>') {\n      throw this.error('Element content may not contain the CDATA section close delimiter `]]>`');\n    }\n\n    this.addText(charData);\n    return true;\n  }\n\n  /**\n   * Consumes a comment if possible.\n   *\n   * @returns Whether a comment was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Comment\n   */\n  consumeComment(): boolean {\n    let { scanner } = this;\n\n    if (!scanner.consumeStringFast('<!--')) {\n      return false;\n    }\n\n    let content = scanner.consumeUntilString('--');\n    this.validateChars(content);\n\n    if (!scanner.consumeStringFast('-->')) {\n      if (scanner.peek(2) === '--') {\n        throw this.error(\"The string `--` isn't allowed inside a comment\");\n      }\n\n      throw this.error('Unclosed comment');\n    }\n\n    if (this.options.preserveComments) {\n      this.addNode(new XmlComment(content.trim()));\n    }\n\n    return true;\n  }\n\n  /**\n   * Consumes a reference in a content context if possible.\n   *\n   * This differs from `consumeReference()` in that a consumed reference will be\n   * added to the document as a text node instead of returned.\n   *\n   * @returns Whether a reference was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#entproc\n   */\n  consumeContentReference(): boolean {\n    let ref = this.consumeReference();\n\n    if (ref) {\n      this.addText(ref);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Consumes a doctype declaration if possible.\n   *\n   * This is a loose implementation since doctype declarations are currently\n   * discarded without further parsing.\n   *\n   * @returns Whether a doctype declaration was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#dtd\n   */\n  consumeDoctypeDeclaration(): boolean {\n    let { scanner } = this;\n\n    if (!scanner.consumeStringFast('<!DOCTYPE')\n        || !this.consumeWhitespace()) {\n\n      return false;\n    }\n\n    scanner.consumeMatch(/[^[>]+/y);\n\n    if (scanner.consumeMatch(/\\[[\\s\\S]+?\\][\\x20\\t\\r\\n]*>/y)) {\n      return true;\n    }\n\n    if (!scanner.consumeStringFast('>')) {\n      throw this.error('Unclosed doctype declaration');\n    }\n\n    return true;\n  }\n\n  /**\n   * Consumes an element if possible.\n   *\n   * @returns Whether an element was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-element\n   */\n  consumeElement(): boolean {\n    let { scanner } = this;\n    let mark = scanner.charIndex;\n\n    if (!scanner.consumeStringFast('<')) {\n      return false;\n    }\n\n    let name = this.consumeName();\n\n    if (!name) {\n      scanner.reset(mark);\n      return false;\n    }\n\n    let attributes = this.consumeAttributes();\n    let isEmpty = Boolean(scanner.consumeStringFast('/>'));\n    let element = new XmlElement(name, attributes);\n\n    element.parent = this.currentNode;\n\n    if (!isEmpty) {\n      if (!scanner.consumeStringFast('>')) {\n        throw this.error(`Unclosed start tag for element \\`${name}\\``);\n      }\n\n      this.currentNode = element;\n\n      do {\n        this.consumeCharData();\n      } while (\n        this.consumeElement()\n          || this.consumeContentReference()\n          || this.consumeCdataSection()\n          || this.consumeProcessingInstruction()\n          || this.consumeComment()\n      );\n\n      let endTagMark = scanner.charIndex;\n      let endTagName;\n\n      if (!scanner.consumeStringFast('</')\n          || !(endTagName = this.consumeName())\n          || endTagName !== name) {\n\n        scanner.reset(endTagMark);\n        throw this.error(`Missing end tag for element ${name}`);\n      }\n\n      this.consumeWhitespace();\n\n      if (!scanner.consumeStringFast('>')) {\n        throw this.error(`Unclosed end tag for element ${name}`);\n      }\n\n      this.currentNode = element.parent;\n    }\n\n    this.addNode(element);\n    return true;\n  }\n\n  /**\n   * Consumes an `Eq` production if possible.\n   *\n   * @returns Whether an `Eq` production was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Eq\n   */\n  consumeEqual(): boolean {\n    this.consumeWhitespace();\n\n    if (this.scanner.consumeStringFast('=')) {\n      this.consumeWhitespace();\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Consumes `Misc` content if possible.\n   *\n   * @returns Whether anything was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Misc\n   */\n  consumeMisc(): boolean {\n    return this.consumeComment()\n      || this.consumeProcessingInstruction()\n      || this.consumeWhitespace();\n  }\n\n  /**\n   * Consumes one or more `Name` characters if possible.\n   *\n   * @returns `Name` characters, or an empty string if none were consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Name\n   */\n  consumeName(): string {\n    return syntax.isNameStartChar(this.scanner.peek())\n      ? this.scanner.consumeMatchFn(syntax.isNameChar)\n      : emptyString;\n  }\n\n  /**\n   * Consumes a processing instruction if possible.\n   *\n   * @returns Whether a processing instruction was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-pi\n   */\n  consumeProcessingInstruction(): boolean {\n    let { scanner } = this;\n    let mark = scanner.charIndex;\n\n    if (!scanner.consumeStringFast('<?')) {\n      return false;\n    }\n\n    let name = this.consumeName();\n\n    if (name) {\n      if (name.toLowerCase() === 'xml') {\n        scanner.reset(mark);\n        throw this.error(\"XML declaration isn't allowed here\");\n      }\n    } else {\n      throw this.error('Invalid processing instruction');\n    }\n\n    if (!this.consumeWhitespace()) {\n      if (scanner.consumeStringFast('?>')) {\n        this.addNode(new XmlProcessingInstruction(name));\n        return true;\n      }\n\n      throw this.error('Whitespace is required after a processing instruction name');\n    }\n\n    let content = scanner.consumeUntilString('?>');\n    this.validateChars(content);\n\n    if (!scanner.consumeStringFast('?>')) {\n      throw this.error('Unterminated processing instruction');\n    }\n\n    this.addNode(new XmlProcessingInstruction(name, content));\n    return true;\n  }\n\n  /**\n   * Consumes a prolog if possible.\n   *\n   * @returns Whether a prolog was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-prolog-dtd\n   */\n  consumeProlog(): boolean {\n    let { scanner } = this;\n    let mark = scanner.charIndex;\n\n    this.consumeXmlDeclaration();\n\n    while (this.consumeMisc()) {} // eslint-disable-line no-empty\n\n    if (this.consumeDoctypeDeclaration()) {\n      while (this.consumeMisc()) {} // eslint-disable-line no-empty\n    }\n\n    return mark < scanner.charIndex;\n  }\n\n  /**\n   * Consumes a reference if possible.\n   *\n   * This differs from `consumeContentReference()` in that a consumed reference\n   * will be returned rather than added to the document.\n   *\n   * @returns\n   *   Parsed reference value, or `false` if nothing was consumed (to\n   *   distinguish from a reference that resolves to an empty string).\n   *\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Reference\n   */\n  consumeReference(): string | false {\n    let { scanner } = this;\n\n    if (!scanner.consumeStringFast('&')) {\n      return false;\n    }\n\n    let ref = scanner.consumeMatchFn(syntax.isReferenceChar);\n\n    if (scanner.consume() !== ';') {\n      throw this.error('Unterminated reference (a reference must end with `;`)');\n    }\n\n    let parsedValue;\n\n    if (ref[0] === '#') {\n      // This is a character reference.\n      let codePoint = ref[1] === 'x'\n        ? parseInt(ref.slice(2), 16) // Hex codepoint.\n        : parseInt(ref.slice(1), 10); // Decimal codepoint.\n\n      if (isNaN(codePoint)) {\n        throw this.error('Invalid character reference');\n      }\n\n      if (!syntax.isXmlCodePoint(codePoint)) {\n        throw this.error('Character reference resolves to an invalid character');\n      }\n\n      parsedValue = String.fromCodePoint(codePoint);\n    } else {\n      // This is an entity reference.\n      parsedValue = syntax.predefinedEntities[ref];\n\n      if (parsedValue === undefined) {\n        let {\n          ignoreUndefinedEntities,\n          resolveUndefinedEntity,\n        } = this.options;\n\n        let wrappedRef = `&${ref};`; // for backcompat with <= 2.x\n\n        if (resolveUndefinedEntity) {\n          let resolvedValue = resolveUndefinedEntity(wrappedRef);\n\n          if (resolvedValue !== null && resolvedValue !== undefined) {\n            let type = typeof resolvedValue;\n\n            if (type !== 'string') {\n              throw new TypeError(`\\`resolveUndefinedEntity()\\` must return a string, \\`null\\`, or \\`undefined\\`, but returned a value of type ${type}`);\n            }\n\n            return resolvedValue;\n          }\n        }\n\n        if (ignoreUndefinedEntities) {\n          return wrappedRef;\n        }\n\n        scanner.reset(-wrappedRef.length);\n        throw this.error(`Named entity isn't defined: ${wrappedRef}`);\n      }\n    }\n\n    return parsedValue;\n  }\n\n  /**\n   * Consumes a `SystemLiteral` if possible.\n   *\n   * A `SystemLiteral` is similar to an attribute value, but allows the\n   * characters `<` and `&` and doesn't replace references.\n   *\n   * @returns\n   *   Value of the `SystemLiteral` minus quotes, or `false` if nothing was\n   *   consumed. An empty string indicates that a `SystemLiteral` was consumed\n   *   but was empty.\n   *\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-SystemLiteral\n   */\n  consumeSystemLiteral(): string | false {\n    let { scanner } = this;\n    let quote = scanner.consumeStringFast('\"') || scanner.consumeStringFast(\"'\");\n\n    if (!quote) {\n      return false;\n    }\n\n    let value = scanner.consumeUntilString(quote);\n    this.validateChars(value);\n\n    if (!scanner.consumeStringFast(quote)) {\n      throw this.error('Missing end quote');\n    }\n\n    return value;\n  }\n\n  /**\n   * Consumes one or more whitespace characters if possible.\n   *\n   * @returns Whether any whitespace characters were consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#white\n   */\n  consumeWhitespace(): boolean {\n    return Boolean(this.scanner.consumeMatchFn(syntax.isWhitespace));\n  }\n\n  /**\n   * Consumes an XML declaration if possible.\n   *\n   * @returns Whether an XML declaration was consumed.\n   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-XMLDecl\n   */\n  consumeXmlDeclaration(): boolean {\n    let { scanner } = this;\n\n    if (!scanner.consumeStringFast('<?xml')) {\n      return false;\n    }\n\n    if (!this.consumeWhitespace()) {\n      throw this.error('Invalid XML declaration');\n    }\n\n    let version = Boolean(scanner.consumeStringFast('version'))\n      && this.consumeEqual()\n      && this.consumeSystemLiteral();\n\n    if (version === false) {\n      throw this.error('XML version is missing or invalid');\n    } else if (!/^1\\.[0-9]+$/.test(version)) {\n      throw this.error('Invalid character in version number');\n    }\n\n    if (this.consumeWhitespace()) {\n      let encoding = Boolean(scanner.consumeStringFast('encoding'))\n        && this.consumeEqual()\n        && this.consumeSystemLiteral();\n\n      if (encoding) {\n        this.consumeWhitespace();\n      }\n\n      let standalone = Boolean(scanner.consumeStringFast('standalone'))\n        && this.consumeEqual()\n        && this.consumeSystemLiteral();\n\n      if (standalone) {\n        if (standalone !== 'yes' && standalone !== 'no') {\n          throw this.error('Only \"yes\" and \"no\" are permitted as values of `standalone`');\n        }\n\n        this.consumeWhitespace();\n      }\n    }\n\n    if (!scanner.consumeStringFast('?>')) {\n      throw this.error('Invalid or unclosed XML declaration');\n    }\n\n    return true;\n  }\n\n  /**\n   * Throws an error at the current scanner position.\n   */\n  error(message: string) {\n    let { charIndex, string: xml } = this.scanner;\n    let column = 1;\n    let excerpt = '';\n    let line = 1;\n\n    // Find the line and column where the error occurred.\n    for (let i = 0; i < charIndex; ++i) {\n      let char = xml[i];\n\n      if (char === '\\n') {\n        column = 1;\n        excerpt = '';\n        line += 1;\n      } else {\n        column += 1;\n        excerpt += char;\n      }\n    }\n\n    let eol = xml.indexOf('\\n', charIndex);\n\n    excerpt += eol === -1\n      ? xml.slice(charIndex)\n      : xml.slice(charIndex, eol);\n\n    let excerptStart = 0;\n\n    // Keep the excerpt below 50 chars, but always keep the error position in\n    // view.\n    if (excerpt.length > 50) {\n      if (column < 40) {\n        excerpt = excerpt.slice(0, 50);\n      } else {\n        excerptStart = column - 20;\n        excerpt = excerpt.slice(excerptStart, column + 30);\n      }\n    }\n\n    let err = new Error(\n      `${message} (line ${line}, column ${column})\\n`\n        + `  ${excerpt}\\n`\n        + ' '.repeat(column - excerptStart + 1) + '^\\n',\n    );\n\n    Object.assign(err, {\n      column,\n      excerpt,\n      line,\n      pos: charIndex,\n    });\n\n    return err;\n  }\n\n  /**\n   * Throws an invalid character error if any character in the given _string_\n   * isn't a valid XML character.\n   */\n  validateChars(string: string) {\n    let { length } = string;\n\n    for (let i = 0; i < length; ++i) {\n      let cp = string.codePointAt(i) as number;\n\n      if (!syntax.isXmlCodePoint(cp)) {\n        this.scanner.reset(-([ ...string ].length - i));\n        throw this.error('Invalid character');\n      }\n\n      if (cp > 65535) {\n        i += 1;\n      }\n    }\n  }\n}\n\n// -- Private Functions --------------------------------------------------------\n\n/**\n * Normalizes the given XML string by stripping a byte order mark (if present)\n * and replacing CRLF sequences and lone CR characters with LF characters.\n */\nfunction normalizeXmlString(xml: string): string {\n  if (xml[0] === '\\uFEFF') {\n    xml = xml.slice(1);\n  }\n\n  return xml.replace(/\\r\\n?/g, '\\n');\n}\n\n// -- Types --------------------------------------------------------------------\nexport type ParserOptions = {\n  /**\n   * When `true`, an undefined named entity (like \"&bogus;\") will be left in the\n   * output as is instead of causing a parse error.\n   *\n   * @default false\n   */\n  ignoreUndefinedEntities?: boolean;\n\n  /**\n   * When `true`, CDATA sections will be preserved in the document as `XmlCdata`\n   * nodes. Otherwise CDATA sections will be represented as `XmlText` nodes,\n   * which keeps the node tree simpler and easier to work with.\n   *\n   * @default false\n   */\n  preserveCdata?: boolean;\n\n  /**\n   * When `true`, comments will be preserved in the document as `XmlComment`\n   * nodes. Otherwise comments will not be included in the node tree.\n   *\n   * @default false\n   */\n  preserveComments?: boolean;\n\n  /**\n   * When an undefined named entity is encountered, this function will be called\n   * with the entity as its only argument. It should return a string value with\n   * which to replace the entity, or `null` or `undefined` to treat the entity\n   * as undefined (which may result in a parse error depending on the value of\n   * `ignoreUndefinedEntities`).\n   */\n  resolveUndefinedEntity?: (entity: string) => string | null | undefined;\n\n  /**\n   * When `true`, attributes in an element's `attributes` object will be sorted\n   * in alphanumeric order by name. Otherwise they'll retain their original\n   * order as found in the XML.\n   *\n   * @default false\n   */\n  sortAttributes?: boolean;\n};\n"],
  "mappings": "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",
  "names": ["src_exports", "__export", "XmlCdata", "XmlComment", "XmlDocument", "XmlElement", "XmlNode", "XmlProcessingInstruction", "XmlText", "parseXml", "emptyString", "surrogatePair", "StringScanner", "string", "charCount", "charLength", "charIndex", "multiByteMode", "charsToBytes", "byteIndex", "isEnd", "charIndexToByteIndex", "_a", "multiByteSafe", "advance", "count", "consume", "chars", "peek", "consumeMatch", "regex", "result", "match", "consumeMatchFn", "fn", "char", "consumeString", "stringToConsume", "consumeStringFast", "length", "charLengthToMatch", "consumeUntilMatch", "restOfString", "matchByteIndex", "consumeUntilString", "searchString", "reset", "index", "attValueCharDoubleQuote", "attValueCharSingleQuote", "attValueNormalizedWhitespace", "endCharData", "predefinedEntities", "isNameChar", "char", "cp", "getCodePoint", "isNameStartChar", "isReferenceChar", "isWhitespace", "isXmlCodePoint", "XmlNode", "_a", "_b", "json", "XmlText", "XmlNode", "text", "XmlCdata", "XmlText", "XmlNode", "XmlComment", "XmlNode", "content", "XmlElement", "XmlNode", "name", "attributes", "children", "node", "child", "XmlDocument", "XmlNode", "children", "child", "XmlElement", "XmlProcessingInstruction", "XmlNode", "name", "content", "emptyString", "Parser", "xml", "options", "XmlDocument", "currentNode", "scanner", "StringScanner", "normalizeXmlString", "consumeProlog", "consumeElement", "error", "consumeMisc", "isEnd", "addNode", "node", "addText", "text", "children", "length", "prevNode", "XmlText", "consumeAttributes", "attributes", "consumeWhitespace", "attrName", "consumeName", "attrValue", "consumeEqual", "consumeAttributeValue", "attrNames", "sortedAttributes", "quote", "peek", "advance", "chars", "isClosed", "value", "regex", "attValueCharDoubleQuote", "attValueCharSingleQuote", "matchLoop", "consumeMatch", "validateChars", "attValueNormalizedWhitespace", "consumeReference", "consumeCdataSection", "consumeStringFast", "consumeUntilString", "XmlCdata", "consumeCharData", "charData", "consumeUntilMatch", "endCharData", "consumeComment", "content", "XmlComment", "consumeContentReference", "ref", "consumeDoctypeDeclaration", "mark", "charIndex", "name", "reset", "isEmpty", "element", "XmlElement", "consumeProcessingInstruction", "endTagMark", "endTagName", "isNameStartChar", "consumeMatchFn", "isNameChar", "XmlProcessingInstruction", "consumeXmlDeclaration", "isReferenceChar", "consume", "parsedValue", "codePoint", "isXmlCodePoint", "predefinedEntities", "ignoreUndefinedEntities", "resolveUndefinedEntity", "wrappedRef", "resolvedValue", "type", "consumeSystemLiteral", "isWhitespace", "version", "standalone", "message", "column", "excerpt", "line", "i", "char", "eol", "excerptStart", "err", "string", "cp", "parseXml", "xml", "options", "Parser"]
}
